<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>视频异常检测领域论文综述</title>
      <link href="/2024/05/10/%E8%A7%86%E9%A2%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E9%A2%86%E5%9F%9F%E8%AE%BA%E6%96%87%E7%BB%BC%E8%BF%B0/"/>
      <url>/2024/05/10/%E8%A7%86%E9%A2%91%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E9%A2%86%E5%9F%9F%E8%AE%BA%E6%96%87%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Video anomaly detection is an important research area in computer vision, with widespread applications in public safety, traffic management, healthcare, and other sectors. With the rapid development of event cameras, their high dynamic range, low latency, and low power consumption make them highly promising for anomaly detection tasks. This paper first introduces the working principles of event cameras and their advantages in the field of video anomaly detection. It then provides a detailed analysis of the main methods and approaches for video anomaly detection, including supervised and unsupervised learning, with the latter divided into reconstruction and prediction-based approaches. I also discuss the challenges faced in the current field, such as scene dependency, the diversity of abnormal behaviors, and data sparsity, and introduce recent advancements in research. Finally, I summarize the methods of modality fusion between event cameras and RGB cameras and propose future research directions and recommendations for improvement, aiming to provide insights for the further development of video anomaly detection tasks.</p><p><strong>Keywords</strong>: Computer Vision, Anomaly Detection, Event Cameras, Unsupervised Learning, Modality Fusion</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>视频异常检测作为计算机视觉的一个重要研究方向，广泛应用于公共安全、交通管理、医疗健康等多个领域。随着事件相机的快速发展，其高动态范围、低延迟和低功耗等特点使其在异常检测任务中具有巨大的应用潜力。本文首先介绍了事件相机的工作原理及其在视频异常检测领域的优势。然后详细分析了现有视频异常检测的主要方法和思路，包括监督学习和无监督学习，在无监督学习中又分为重建和预测两大方向。接着，我探讨了当前领域面临的挑战，如场景依赖性、异常行为的多样性、数据稀疏性等，并介绍了近年来的前沿研究成果。最后，我对事件相机与RGB相机的模态融合方法进行了总结，并提出了未来的研究方向和改进建议，旨在为视频异常检测任务的进一步发展提供思路。</p><p><strong>关键词</strong>：计算机视觉、异常检测、事件相机、无监督学习、模态融合</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>视频异常检测是计算机视觉领域中的一个核心研究方向，其主要目的是从视频数据中识别出异常事件。随着现代社会对安全与监控需求的日益增加，视频监控系统已被广泛应用于各种场景中，成为确保公共安全和财产安全的重要手段。例如，在城市交通管理中，视频监控不仅用于监控车辆流量，还用于检测交通事故、违法行为等异常事件；在工业制造中，视频监控被用于发现生产过程中的故障和危险操作；在医疗健康领域，视频监控可用于监测患者的行为和状态，及时发现潜在的紧急情况。因此，如何通过视频数据自动检测这些异常行为成为一个至关重要的问题。</p><p>传统的基于帧捕捉的相机虽能完成视频监控的任务，但在处理复杂动态场景时存在一些不足，尤其是在面对快速变化的场景和环境时，常规相机的帧率限制可能导致信息丢失或延迟。随着技术的发展，事件相机作为一种新型视觉传感器，逐渐进入了视频异常检测的研究视野。与传统相机不同，事件相机并不依赖固定的帧率进行图像捕捉，而是仅记录像素亮度的变化事件。这种“事件驱动”的捕捉方式使其具备了高动态范围、低延迟以及低功耗的特点，使得事件相机在处理高速动态变化的场景时表现尤为出色。</p><p>事件相机的这些特点，使其特别适合用于视频异常检测任务。与传统相机相比，事件相机不仅可以更加高效地捕捉快速发生的异常事件，还能够在低光照、强对比等极端环境下保持较高的检测精度。这对于那些需要在实时监控中快速做出反应的应用场景，如安防系统、自动驾驶、工业机器人监控等，具有极大的潜在价值。因此，基于事件相机的视频异常检测技术正在迅速崛起，成为该领域研究的一个重要方向。</p><p>随着事件相机技术的不断发展，它为视频异常检测任务提供了新的思路和解决方案。事件相机不仅克服了传统相机的局限性，还显著提高了检测的效率和准确性。因此，越来越多的研究者开始关注如何将事件相机应用于视频异常检测，并探索其在各种复杂动态场景中的应用潜力。</p><h2 id="事件相机简介"><a href="#事件相机简介" class="headerlink" title="事件相机简介"></a>事件相机简介</h2><p>事件相机与传统相机的主要区别在于其工作原理。传统相机以固定的帧率捕捉整个场景的图像，而事件相机仅记录像素亮度的变化，即“事件”。这种工作方式使得事件相机具有低延迟、高动态范围和低功耗的特点，极大地提高了对动态场景捕捉的效率和准确性。</p><p><img src="/事件相机.jpg" alt="使用V2E对ShanghaiTech数据集进行事件化示例"></p><h2 id="常用于视频异常检测的方法"><a href="#常用于视频异常检测的方法" class="headerlink" title="常用于视频异常检测的方法"></a>常用于视频异常检测的方法</h2><p>目前常用于视频异常检测的方法分为监督学习和无监督学习两大类。</p><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a><strong>监督学习</strong></h3><p>在监督学习方法中，模型的训练依赖于预先标注的数据集，即每个视频片段或帧都被明确地标注为“正常”或“异常”。这种方法的发展基于分类和回归两种主要思路。基于分类的方法通过将所有数据样本映射到不同的类别标签中，即模型根据输入的视频特征对其进行分类，判断是否属于异常行为。基于回归的方法则是将每个数据样本映射到一个连续的异常分数空间，模型会根据输入特征计算出一个异常分数，分数越高意味着该样本越可能是异常。</p><p>尽管监督学习方法在一些特定应用场景中表现出色，但它的一个主要问题在于对大规模、精确标注数据的依赖。由于视频异常检测通常涉及多个领域，异常事件的类型和表现形式差异很大，因此一个能够涵盖所有异常情况的完整数据集难以构建。更为复杂的是，标注数据的成本非常高，特别是在长时间的视频监控场景中，人工标注每个异常事件几乎不可能实现。此外，粗粒度的标签也会影响模型的表现，因为它们无法提供足够细致的异常信息，这可能导致模型误分类或漏检。</p><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a><strong>无监督学习</strong></h3><p>与监督学习方法不同，无监督学习方法不依赖于预先标注的数据，而是试图通过从未标注数据中自动发现异常模式。在无监督学习中，主要分为基于重建和基于预测两大类方法。</p><p>基于<strong>重建</strong>的方法假设模型在训练过程中通过学习正常行为特征，能够对正常数据进行较为准确的重建，但对于异常数据的重建则会产生较大的误差。因此，模型可以通过在测试阶段计算重建误差来判断是否为异常数据。当重建误差超过一定阈值时，数据被判定为异常。这种方法不依赖标签，且在正常数据较为丰富的情况下效果较好。</p><p>基于<strong>预测</strong>的方法认为，正常视频中的帧与帧之间存在某种规律性的上下文关系，模型可以通过学习这种关系来预测未来帧。当模型无法准确预测未来帧，或者预测误差较大时，意味着该段视频可能包含异常行为。预测模型通常会基于过去的视频帧来推测未来帧的特征，异常帧因为违背了正常帧之间的依赖关系，导致模型难以做出准确预测，从而使得预测误差增大。</p><p>无监督学习方法的一个显著优势是其对数据标签的依赖较小，因此在标签匮乏或无法准确标注的情况下表现良好。然而，这类方法也存在一些缺陷。例如，当模型的泛化能力过强时，可能会过度拟合正常和异常数据，导致异常数据也被准确重建或预测，进而降低检测准确率。此外，某些正常但较为少见的数据样本，可能因其独特性而被模型误判为异常。因此，尽管无监督学习方法在当前视频异常检测研究中占据主流地位，但仍然面临着挑战，需要进一步提升模型的鲁棒性和准确性。</p><h2 id="亟待解决的问题"><a href="#亟待解决的问题" class="headerlink" title="亟待解决的问题"></a>亟待解决的问题</h2><p>尽管已有无数研究者投身于视频异常检测领域的研究，该领域目前仍然面临一系列挑战</p><p><strong>1. 场景性</strong>：视频中的异常事件通常不是孤立的，而是与特定场景、环境或真实情境相关联。这意味着异常的定义和判断需要考虑视频所处的具体场景。例如，在某场景正常的行为，在另一场景就为异常，解决异常的场景依赖问题是提高模型泛化能力的关键。</p><p><strong>2. 模糊性</strong>：异常检测被广泛认为是检测在特定情况下预期不会出现的事件的过程。然而，在现实世界中，正常和异常之间的边界没有明确划分。例如，一些正常样本也会表现出异常事件所具有的奇怪特征，这阻碍了模型的检测精度。</p><p><strong>3. 多样性</strong>：现实世界中的异常行为多种多样，无法完全说明，有时甚至可能尚未发生。因此，在一个数据集中考虑所有可能的异常类型是不切实际的。那么如何让模型在将众多未见的或正常或异常的行为区分开来是视频异常检测领域的一大难题。</p><p><strong>4. 稀疏性</strong>：由于行为的种类繁多，视频异常检测领域的数据集通常有单个行为的数据过少，异常样本明显少于正常样本的不平衡等问题。</p><p><strong>5. 噪声</strong>：在视频异常检测中，监控画面常作为数据集，但这种数据集中的信息密度过低，而且对于长时间视频的标签标注是一个十分耗时的过程。对于一个粗粒度的标签，模型还很有可能错误的学习到了噪声与标签的关系，数据中的高噪声无疑影响着任务的性能。</p><p><strong>6. 隐私性</strong>：监控等视频数据具有隐私性，这限制了视频异常检测在某些领域的数据获取。</p><h2 id="最新解决方法"><a href="#最新解决方法" class="headerlink" title="最新解决方法"></a>最新解决方法</h2><p>解决场景相关问题：</p><p><strong>Sun, S.</strong><a href="#1">[1]</a>等人要解决的关键问题是视频异常检测中的场景性问题即<strong>如何提高场景感知能力，以便检测出场景相关的异常事件</strong>。并应对正常的多样性，让模型学习到不同的正常现象。</p><p>解决思想是利用预训练的视频解析网络提取前景对象和背景场景的高层语义特征，然后利用场景感知的自编码器和层次语义对比学习来学习其中的特征和之间的关系。在测试时，根据输入视频的语义类别，检索高相关的正常特征进行重建，重建误差较高的片段被检测为异常。</p><p>实现方法：</p><ul><li>视频解析：利用预训练的视频解析模型，将前景对象和背景场景的特征分为不同的语义类别。具体使用YOLOv3和FairMOT检测和跟踪对象，使用ViT和PoseConv3D提取对象的外观和动作特征，使用DeepLabV3+生成背景场景的分割图，并使用DBSCAN进行场景聚类。</li><li>层次语义对比：将每个对象的外观或运动特征与对应的场景特征结合起来，形成场景—外观或场景-运动特征，然后用自编码器进行编码和重建。在编码过程中，引入层次语义对比学习，使得编码后的潜在特征在同一语义类别内紧凑，在不同语义类别间分离。<br><img src="/image-20241010153155488.png" alt="外貌和运动特征在场景中进行对比学习"></li><li>语义特征重建：在测试时，从外部记忆库中检索和加权正常特征来重建测试视频中的对象特征，并根据重建误差来判断异常。重建误差越大，异常得分越高。</li><li><p>动作增强：为了处理稀有但正常的活动，设计了一个基于骨架的增强方法，通过空间变换和时间裁剪来生成更多的正常和异常样本，进一步训练一个二分类器来提升性能。</p><p><img src="/image-20241010153613993.png" alt="基于骨骼的运动增强，包括空间变换和时间切割"></p></li></ul><p>研究贡献是提出了一种层次语义对比方法，有效地利用了预训练网络提供的高层语义信息，让计算机更好地理解和表示正常视频中出现的场景和对象，以及它们之间的关系，提高了正常模式的表示和判别能力。设计了一种场景感知的自编码器结构，结合了背景场景和前景对象的信息，同时减少了重建过程中的背景噪声。和设计了一种基于骨架的动作增强方法，增加了稀有活动的样本数量，帮助处理正常模式的不平衡问题。不足之处在于模型中的某些模块也可以用其他更先进的模块替换，例如使用另一种更好的背景解析模型来代替简单的分割图以区分背景的方法。</p><p><strong>Cao, C.</strong><a href="#2">[2]</a>等人想要解决的关键问题是<strong>半监督视频异常检测和异常预测，特别是场景依赖的异常</strong>，给出了另一种解决场景性的方案。</p><p>解决思想是利用前向和后向帧预测模型来估计当前和未来帧的异常分数，同时利用场景条件的变分自编码器来处理场景依赖的异常。</p><p>实现方法是设计了一个前向-后向场景条件自编码器（FBSCAE），包括一个前向网络和一个后向网络，分别用于前向和后向帧预测。每个网络都是一个三层U-Net，包含了条件变分自编码器（CVAE），将场景图像作为输入条件，引导输入帧的特征与场景相关（处理与场景有关的异常）。在训练阶段，使用均方误差损失、L1损失和KL散度损失来优化模型。在推理阶段，使用前向预测误差作为视频异常检测（VAD）的分数，使用前向-后向预测误差的最大值作为视频异常预测（VAA）的分数。</p><p>研究贡献是提出了一个新的大规模数据集NWPU Campus，它是目前最大的半监督视频异常检测基准，也是唯一考虑场景依赖异常和视频异常预测的数据集。提出了一个新的视频异常预测任务，旨在提前预测异常事件的发生，这对于异常事件的预警具有重要意义。不足之处在于对于长期的异常预测还有待改进，以及对于低分辨率的数据集表现不佳。</p><p><img src="/image-20241010161712530.png" alt="NWPU Campus dataset"></p><p>生成虚拟异常增强数据集：</p><p><strong>Liu, Z.</strong><a href="#3">[3]</a>等人想要解决的关键问题是<strong>提高模型对于异常判断的泛化能力</strong>。由于异常事件的稀疏性和多样性，目前的模型往往难以泛化到未见过的异常类型。</p><p>解决思想是提出一种基于提示的特征映射框架（PFMF），通过在特征层面进行正常特征到异常特征的映射，来生成数据集中未见过的异常类型。同时，引入了一个异常提示来指导映射的方向，使得生成的异常具有无界的多样性。此外，还设计了一个映射适应分支，通过异常分类器和域分类器来缩小场景差距，使得生成的异常具有场景特异性和一致性。</p><p><img src="/image-20241010162250537.png" alt="PFMF框架"></p><p>实现方法是PFMF包含三个部分，即特征提取器、基于提示的特征映射网络和映射适应分支。特征提取器用于将输入的视频实例转换为对应的特征，映射网络用于在同一域内将正常特征映射到异常特征空间，异常提示用于从一个变分自编码器（VAE）中采样，作为映射网络的额外输入，映射适应分支用于对生成的异常特征进行场景适应，包括一个异常分类器和两个域分类器。PFMF的训练过程是统一的，包括特征映射损失、异常分类损失、域分类损失和VAE重构损失。PFMF的推理过程是完全监督的，给定一个未见过的视频实例，通过特征提取器和异常分类器得到实例级别的异常分数，然后通过最大值得到帧级别的异常分数。</p><p>PFMF的优点是能够利用虚拟数据集来生成无界的异常类型，提高了VAD的泛化能力；同时能够通过映射适应分支来缩小虚拟和真实场景之间的差距，提高了VAD的鲁棒性。PFMF的缺点是需要依赖于YOLOv3检测器来提取人物的边界框，这可能会引入一些误差。</p><p>生成伪标签增强数据集：</p><p><strong>Zhang, C.</strong><a href="#4">[4]</a>等人想要解决的关键问题是在弱监督视频异常检测中，<strong>如果数据只有视频级别的标签，如何预测出准确的帧级别的标签。并使用生成出的帧级别的伪标签用于自训练，增强训练效果。</strong></p><p>解决思想是利用完整性和不确定性两个属性来提高伪标签的质量，从而提高异常检测的性能。</p><p>实现方法：</p><ul><li>完整性：设计一个伪标签生成器包含多头分类器，并引入多样性损失， 这样每个头往往会发现不同的异常事件，从而使伪标签生成器覆盖尽可能多的异常事件。</li><li>不确定性：设计一个迭代的不确定性感知的伪标签精炼策略：利用MC Dropout来估计伪标签的不确定性，并根据不确定性选择可靠的样本来训练最终的分类器。</li><li>迭代：使用可靠的样本和可靠的伪标签来训练一个新的帧分类器。用新的帧分类器更新伪标签，并重复上述步骤，直到模型收敛。</li></ul><p>模型优点是能够有效地利用视频中的完整性和不确定性信息，生成高质量的伪标签，从而提高异常检测的准确性和鲁棒性。缺点是需要进行多次迭代和不确定性估计，计算开销较大。</p><p><strong>Mastan, I. D.</strong><a href="#5">[5]</a>等人想要解决的关键问题是<strong>如何在不使用训练数据的情况下，实现图像恢复和图像重定向的任务</strong>，即从单张图像中学习有效的图像特征，并生成不同尺寸或比例的目标图像。解决这个问题可以提高基于重建的视频异常检测任务的性能。</p><p>解决思想是利用深度网络结构作为隐含的图像先验，结合内部学习和上下文特征学习的方法，构建一个通用的框架，通过最小化源图像和目标图像在不同特征表示下的差异，来实现图像恢复和图像重定向。</p><p><img src="/image-20241010164645927.png" alt="DCIL框架"></p><p>实现方法是提出了深度上下文内部学习（DCIL）框架，包括以下几个模块：</p><ul><li>网络构建模块：使用一个编码器-解码器结构的生成器网络和一个多尺度补丁判别器网络，根据不同的任务设置网络层、跳跃连接、级联输入和残差块等组件。</li><li>损失函数模块：使用三种损失函数来优化生成器网络，分别是上下文损失（LCL）、对抗损失（LGAN）和重建损失（LR）。上下文损失用于增强生成图像的上下文特征，对抗损失用于匹配源图像和生成图像的补丁分布，重建损失用于保留源图像的全局特征。</li><li>应用模块：根据不同的应用场景，如去噪超分辨率（DSR）、超分辨率（SR）和图像重定向（IR），设置不同的缩放因子、网络参数和损失函数权重，来实现从单张图像中生成不同尺寸或比例的目标图像。</li></ul><p>DCIL框架的优点是不需要任何训练数据，只利用单张图像中的内部信息来学习图像特征，避免了训练数据集的限制和偏差。并且DCIL框架可以适应多种图像恢复和图像重定向的任务，只需要调整网络结构和损失函数的设置，就可以实现不同的目标。论文还将网络结构和损失函数进行了模块化设计，便于调整。DCIL框架的缺点是依赖于单张图像中的自相似性作为先验信息，当源图像中存在高度噪声或低相关性时，可能无法学习到有效的图像特征，并导致生成质量下降。</p><p><strong>Lv, H.</strong><a href="#6">[6]</a>等人想要解决的关键问题是<strong>弱监督视频异常检测</strong>（WSVAD），即利用只有视频级别的二元异常标签（正常或异常）来训练一个片段级别的异常检测器。<strong>需要克服多实例学习（MIL）中的假警报和上下文偏差问题（视频级分类正确但帧级分类错误）</strong>。</p><p>解决思想是提出一个无偏差的多实例学习（UMIL）框架，通过寻求不同上下文偏差的片段之间的不变性来学习无偏差的异常特征。</p><p><img src="/image-20241010163506908.png" alt="UMIL框架"></p><p>实现方法：</p><ul><li>划分片段：根据当前的异常检测器f，将视频片段分为两个集合：可信片段集C和模糊片段集A。C中的片段是明显正常或异常的，A中的片段是不确定的。</li><li>聚类模糊片段：利用一个无监督的聚类头g，将A中的片段特征分为两个簇，以区分正常和异常片段。g通过最小化预测相似度的二元交叉熵损失来训练。（利用dot-product进行无监督的二元分类，分类后的信息会作为第三步的监督）</li><li>训练异常检测器：在C和A上同时训练异常检测器f，使其能够预测C中的二元标签，以及分离A中的两个簇（由第二步生成）。这样可以消除C中的上下文偏置，并学习无偏置的异常特征。</li></ul><p>UMIL的优点是能够利用模糊片段来消除可信片段中的上下文偏差，提高WSVAD的性能和鲁棒性。能够将特征表示微调和异常检测器学习整合到一个端到端的训练方式中，得到一个更适合VAD的特征表示。并且采用了一种细粒度的视频划分策略（将每个视频划分为长度为一秒的片段，而不是使用每个粗粒度片段的平均特征作为分类器的输入），保留了视频片段中微妙的异常信息。UMIL的缺点是依赖于无监督聚类来区分模糊片段，其性能受到聚类算法和参数选择的影响。需要预先训练一个MIL模型来初始化异常检测器，并且需要追踪每个片段的预测历史来划分可信和模糊片段，增加了计算开销。</p><p><strong>Yang, Z.</strong><a href="#7">[7]</a>等人想要解决的关键问题是<strong>如何将视频中更高层次的视觉特征和综合的时空关系用于视频异常检测任务中</strong>。</p><p>解决思想是提出一种全新（不同于帧重建、帧预测等）的视频异常检测方法：基于关键帧恢复视频事件的方法。该方法鼓励DNN根据包含隐含的外观和运动关系的视频关键帧来推断缺失的多帧，从而恢复视频事件，这可以更有效地激励DNN挖掘和学习视频中潜在的高层次视觉特征和综合时空变化关系。</p><p>实现方法是提出了一种新颖的U形Swin Transformer网络（USTN-DSC），其中引入了一个交叉注意力和一个时域上采样残差跳跃连接来进一步辅助恢复视频中复杂的静态和动态运动对象特征。此外，还提出了一种简单有效的相邻帧差分损失来约束视频序列的运动一致性。</p><p>模型优点是能够更好地捕捉视频中长距离的时空依赖关系，提高对异常事件的敏感性和区分度。不足之处是需要更多的计算资源和训练时间，以及对不同场景和运动模式的泛化能力还有待提高。</p><p>Event数据中的特征提取工具：</p><p><strong>Peng, Y.</strong><a href="#8">[8]</a>等人想要解决的关键问题是如何<strong>利用Transformer网络来提取事件相机数据中的空间、时间和极性信息</strong>，从而提高事件视觉任务的性能。</p><p>解决思想是提出一种新的事件表示方法，称为Group Token，将异步事件根据时间戳和极性进行分组，并设计一个新的Transformer网络，称为Group Event Transformer (GET)，在Group Token上进行有效的特征提取和整合。</p><p>实现方法：GET包括三个主要模块：Group Token Embedding (GTE)、Event Dual Self-Attention (EDSA) block和Group Token Aggregation (GTA) module。GTE将事件流转换为Group Token，EDSA block在空间和时间—极性维度上进行局部自注意力操作，并建立双重残差连接，提取事件相机数据的空间和时间—极性特征，GTA module利用重叠分组卷积来实现两个维度的信息整合和解耦。</p><p>GET的优点是能够充分利用事件数据的特性，提高事件视觉任务的性能，同时具有较低的计算成本和模型大小。GET的缺点是需要根据不同的数据集和任务来调整Group Token的生成参数，以达到最佳效果。</p><h2 id="事件相机对视频异常检测的帮助"><a href="#事件相机对视频异常检测的帮助" class="headerlink" title="事件相机对视频异常检测的帮助"></a>事件相机对视频异常检测的帮助</h2><ol><li>利用事件相机的低数据率、低能耗的优点降低异常检测的模型训练成本和应用的成本。</li><li>事件相机能大大减少视频中的隐私信息，解决异常检测的数据和应用中存在的隐私方面的问题。</li><li>利用事件相机的高动态范围的优点可以提高模型在低/高亮度等画面下的健壮性。</li><li>由于事件相机对变化的敏感性，可以借助对变化敏感事件相机数据对异常检测进行辅助。<strong>Liu, Z.</strong><a href="#9">[9]</a>等人就利用了事件相机来辅助交通领域的物体检测，并且发现事件相机在动态物体检测贡献较大。</li></ol><h2 id="事件相机与RGB相机的模态融合方法"><a href="#事件相机与RGB相机的模态融合方法" class="headerlink" title="事件相机与RGB相机的模态融合方法"></a>事件相机与RGB相机的模态融合方法</h2><p><strong>Yang, Y.</strong><a href="#10">[10]</a>等人提出了一个用于事件引导HDR视频重建的多模态学习框架。为了更好地利用两种视觉信号模态对同一场景的了解，该文提出一种学习共享潜在空间的多模态表示对齐策略，以及针对不同区域不同动态范围对两类信号进行互补的融合模块。并且利用时间相关性来抑制重建的HDR视频中的闪烁效果。</p><p>实现方法是将事件相机与RGB相机的数据投影到共享表示空间上，使得两种模态的数据对齐。再使用置信度引导的多模态融合模块，分步执行模态间重建和模态内重建，最后将两个编码器和 HDR 解码器联合训练。</p><p><strong>Zhu, Z.</strong><a href="#11">[11]</a>等人基于预训练的ViT框架，鼓励ViT弥合两种模式之间的巨大分布差距，实现全面的跨模式信息交互，从而增强其能力。</p><p>实现方法是提出一种掩码建模策略，该策略随机屏蔽某些token的特定模态，以强制来自不同模态的token主动交互。还提出了一个正交高秩损失来正则化注意力矩阵，用于抑制跨模态掩码引起的图像闪烁，同时放大其积极作用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在完成了对视频异常检测领域的深入探讨与研究后，我们可以看到，尽管在这一领域已经取得了显著进展，但仍有许多挑战和未解决的问题等待着科研工作者们的攻克。我们认为在视频异常检测任务中，加入事件相机是一个新颖的创新点。由于其独特的特点，在提高视频异常检测准确性和效率上都将发挥很大的作用。</p><p>通过广泛阅读论文，明确了视频异常检测领域的常用方法和亟待解决的问题后，我们开始思考如何在现有的研究上加入事件相机。为此我们进一步的翻阅了相关论文，总结目前的模态融合方法，寻找适合两种模态的编解码器，着手于模型搭建和进一步的实验设计于验证。</p><p>在未来的工作中，我们希望能够找到更为有效的解决方案，以应对视频异常检测领域所面临的挑战。最终，我们相信，通过不断的努力和探索，视频异常检测的研究将为我们带来更安全、更智能的生活环境。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p><a id="1">[1]</a> Sun, S., &amp; Gong, X. (2023). Hierarchical Semantic Contrast for Scene-Aware Video Anomaly Detection. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pp. 22846–22856.</p><p><a id="2">[2]</a> Cao, C., Lu, Y., Wang, P., &amp; Zhang, Y. (2023). A New Comprehensive Benchmark for Semi-Supervised Video Anomaly Detection and Anticipation. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pp. 20392–20401.</p><p><a id="3">[3]</a>Liu, Z., Wu, X., Zheng, D., Lin, K., &amp; Zheng, W. (2023). Generating Anomalies for Video Anomaly Detection With Prompt-Based Feature Mapping. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pp. 24500–24510.</p><p><a id="4">[4]</a> Zhang, C., Li, G., Qi, Y., et al. (2023). Exploiting Completeness and Uncertainty of Pseudo Labels for Weakly Supervised Video Anomaly Detection. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pp. 16271–16280.</p><p><a id="5">[5]</a> Mastan, I. D., &amp; Raman, S. (2020). DCIL: Deep Contextual Internal Learning for Image Restoration and Image Retargeting. Proceedings of the IEEE/CVF Winter Conference on Applications of Computer Vision (WACV), pp. 2366–2375.</p><p><a id="6">[6]</a> Lv, H., Yue, Z., Sun, Q., et al. (2023). Unbiased Multiple Instance Learning for Weakly Supervised Video Anomaly Detection. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pp. 8022–8031.</p><p><a id="7">[7]</a> Yang, Z., Liu, J., Wu, Z., et al. (2023). Video Event Restoration Based on Keyframes for Video Anomaly Detection. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pp. 14592–14601.</p><p><a id="8">[8]</a> Peng, Y., Zhang, Y., Xiong, Z., et al. (2023). GET: Group Event Transformer for Event-Based Vision. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pp. 6038–6048.</p><p><a id="9">[9]</a> Liu, Z., Yang, N., Wang, Y., Li, Y., Zhao, X., &amp; Wang, F. (2023). Enhancing Traffic Object Detection in Variable Illumination with RGB-Event Fusion. ArXiv, abs/2311.00436.</p><p><a id="10">[10]</a> Yang, Y., Han, J., Liang, J., et al. (2023). Learning Event Guided High Dynamic Range Video Reconstruction. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pp. 13924–13934.</p><p><a id="11">[11]</a> Zhu, Z., Hou, J., &amp; Wu, D. O. (2023). Cross-Modal Orthogonal High-Rank Augmentation for RGB-Event Transformer-Trackers. Proceedings of the IEEE/CVF International Conference on Computer Vision (ICCV), pp. 22045–22055</p>]]></content>
      
      
      <categories>
          
          <category> 科研日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 综述 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 视频异常检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速让个人博客被搜索引擎收录</title>
      <link href="/2024/03/13/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%AE%A9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%A2%AB%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95/"/>
      <url>/2024/03/13/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%AE%A9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%A2%AB%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们好不容易搭建好自己的个人博客时，在搜索引擎搜索时才发现，无论是搜索网站的标题还是网址都无法搜索到，搜索不到就代表着没有流量、没人看你写的文章，这可咋办。难道辛辛苦苦搭建的网站只有知道网址的人才能访问到吗，如何打破这信息孤岛呢？下面交给你解决办法，把你的网站主动推荐给各大搜索引擎让搜索引擎收录。</p><p>由于各大搜索引擎的本质就是一个爬虫在不断爬取互联网上的内容，也许你的网站在不经意间已经被收录了。</p><p>你可以通过在搜索引擎中输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:&lt;域名&gt; （e.g. site:xiaobaozi.cn）</span><br></pre></td></tr></table></figure><p>若可以搜索出你的网站，则说明已经被收录。</p><p>不过你仍可以进行接下来的步骤，在各大搜索引擎的后台添加你的网站并绑定你的账号，之后你就可以在后台看到相关的流量统计和相关增加曝光度的操作。</p><h2 id="百度收录"><a href="#百度收录" class="headerlink" title="百度收录"></a>百度收录</h2><p>若未被收录，可以点击<a href="https://ziyuan.baidu.com/linksubmit/url?sitename">提交网址</a></p><p><img src="/百度未收录.png" alt=""></p><p>进行连接提交（这是搜索引擎用户对搜索不到的网址进行反馈提交，无法保证收录）</p><p><img src="/image-20240314001014339.png" alt=""></p><p>若要进一步提交网站可以选择</p><h3 id="添加站点到百度"><a href="#添加站点到百度" class="headerlink" title="添加站点到百度"></a>添加站点到百度</h3><p>我们需要登录<a href="https://ziyuan.baidu.com/">百度搜索资源平台</a>，登录成功之后在上方用户中心→<a href="https://ziyuan.baidu.com/site">站点管理</a>中点击添加网站，输入域名，按照步骤走。</p><p><img src="/image-20240314001927371.png" alt=""></p><p>进入第三步验证您对网站的所有权，可以选择文件验证或HTML标签认证。</p><h4 id="文件验证"><a href="#文件验证" class="headerlink" title="文件验证"></a>文件验证</h4><p><img src="/文件验证.png" alt=""></p><ol><li>下载验证文件，放到指定目录下。以hexo搭建的博客为例，放到 <code>博客目录/public</code>目录下。</li><li>执行 <code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code>命令即可。</li><li>等待网站更新，在你的网站域名后添加验证文件的文件名（e.g. <code>https://www.xiaobaozi.cn/baidu_verify_codeva-&lt;xxxxx&gt;.html</code>)，若能访问到一串字符串说明成功。（仅出现一串字符串在左上角，其余为空白，无其他内容）</li><li>成功后点击 <code>完成验证</code>即可</li></ol><h3 id="向百度推送网站的资源"><a href="#向百度推送网站的资源" class="headerlink" title="向百度推送网站的资源"></a>向百度推送网站的资源</h3><p>经过上面的步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。还是在百度资源搜索平台上方点击搜索服务→资源提交→<a href="https://ziyuan.baidu.com/linksubmit/index">普通收录</a></p><p>资源提交的方式有多种</p><p><a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=3#h2_article_title8">如何选择普通收录方式</a></p><ul><li><strong>API推送：</strong>最为快速的提交方式，建议您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。</li><li><strong>sitemap：</strong>您可以定期将网站链接放到Sitemap中，然后将Sitemap提交给百度。百度会周期性的抓取检查您提交的Sitemap，对其中的链接进行处理，但收录速度慢于API推送。</li><li><strong>手动提交：</strong>如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度。</li></ul><h4 id="API提交"><a href="#API提交" class="headerlink" title="API提交"></a>API提交</h4><p>API提交首先需要安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>然后在 hexo 根目录配置文件 <code>_config.yml</code> 中，添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主动推送百度，被百度收录</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">10</span> <span class="comment"># 提交最新的10个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="comment"># 百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="comment"># 密钥，百度站长平台 &gt; 普通收录 &gt; 推送接口 &gt; 接口调用地址中token字段</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 文本文档的地址， 新链接会保存在此文本文档里，不用改</span></span><br></pre></td></tr></table></figure><p><img src="/百度.png" alt="百度"></p><p>其次，记得查看 hexo 根目录中 <code>_config.yml</code> 文件中 <code>url</code> 的值， 必须包含是百度站长平台注册的域名。</p><p>最后，在 <code>_config.yml</code> 文件中的 <code>deploy</code> 加入新的 <code>type</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">git@github.com:Warma10032/Warma10032.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br></pre></td></tr></table></figure><div class="note warning modern"><p>这里是新建一个 type，一定要注意这段代码里面各行的缩进值</p></div><p>执行 <code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code>命令即可。</p><p>后续慢慢等收录吧，百度收录比较慢。</p><h4 id="Sitemap"><a href="#Sitemap" class="headerlink" title="Sitemap"></a>Sitemap</h4><div class="note danger modern"><p>目前百度正在清理陈旧sitemap文件，并且关闭了个人小站的添加sitemap的入口。对于有域名有备案的网站可以登录百度查看是否可以提交sitemap文件。</p></div><div class="note info modern"><p>Sitemap（站点地图）是一种文件的统称，通常Sitemap（站点地图）可以是txt或者XML格式。通过Sitemap（站点地图）你可以告诉搜索引擎关于你的站点中的网页、视频或者其他文件的相关信息，帮助搜索引擎更好的认识和理解你的站点。格式正确的Sitemap（站点地图）文件会帮助搜索引擎更高效地抓取你的网站。</p></div><p>通过sitemap方式推送我们首先需要生成一个站点地图。</p><p>安装百度和 Google 的站点地图生成插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save </span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>然后来到 hexo 根目录配置文件 <code>_config.yml</code>，在下面添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 站点地图</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure><p>安装完成后我们执行 <code>hexo cl &amp;&amp; hexo g</code>命令后我们会发现在 <code>public</code>目录下面多了 <code>baidusitemap.xml</code>和 <code>sitemap.xml</code>文件。 我们打开文件可以看到生成的其实就是我们每篇文章的url。</p><p>然后重新推送到服务器，访问如下 URL:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://你的域名/sitemap.xml</span><br><span class="line">https://你的域名/baidusitemap.xml</span><br></pre></td></tr></table></figure><p>看看网页中有没有内容，有的话就成功。</p><p>最后将 <code>https://你的域名/baidusitemap.xml</code>填入并提交即可。</p><p><img src="/image-20240328125839744.png" alt=""></p><div class="note primary modern"><p>Google Sitemap提交 <code>https://你的域名/sitemap.xml</code>，方法类似，不再赘述。</p></div><h4 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h4><p>即手动将你的连接输入并提交。</p><h2 id="谷歌收录"><a href="#谷歌收录" class="headerlink" title="谷歌收录"></a>谷歌收录</h2><p>提交谷歌搜索引擎比较简单，在提交之前，我们依然可以使用 <code>site:域名</code> 查看网站是否被收录。进入 <a href="https://developers.google.com/search#?modal_active=none">Google 搜索中心</a>，登录你的谷歌账号。然后找到<a href="https://search.google.com/search-console/welcome">注册 Search Console</a>(在 “使用入门–&gt;SEO 新手指南” 中可以找到入口)，就直接输入你要收录的网站域名就行。</p><p><img src="/image-20240328131702702.png" alt=""></p><h3 id="网域"><a href="#网域" class="headerlink" title="网域"></a>网域</h3><p>输入你的域名后进行DNS验证。</p><p><img src="/image-20240328184321578.png" alt=""></p><p>以腾讯云为例。</p><p>进入域名解析添加解析记录即可。</p><p><img src="/image-20240328184907173.png" alt=""></p><h3 id="网址前缀"><a href="#网址前缀" class="headerlink" title="网址前缀"></a>网址前缀</h3><p>按示例格式输入你的网址前缀后，Google会收录所有以该前缀开头的网址。</p><p>需要进行网站所有权验证，选HTML文件验证，与百度收录类似。</p><p><img src="/image-20240328191231313.png" alt=""></p><ol><li>下载验证文件，放到指定目录下。以hexo搭建的博客为例，放到 <code>博客目录/public</code>目录下。</li><li>执行 <code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code>命令即可。</li><li>等待网站更新，在你的网站域名后添加验证文件的文件名（e.g. <code>https://www.xiaobaozi.cn/google&lt;xxxxx&gt;.html</code>)，若能访问到一串字符串说明成功。（仅出现一串字符串在左上角，其余为空白，无其他内容）</li><li>成功后点击 <code>验证</code>即可</li></ol><h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><p>Google收录速度很快，对站点地图也不是刚需。不过也可以在对应页面上传你的站点地图文件，便于Google爬取。</p><h2 id="必应收录"><a href="#必应收录" class="headerlink" title="必应收录"></a>必应收录</h2><p>必应收录也是很简单，点击<a href="https://www.bing.com/webmasters/about">必应站长</a>。先注册登录，必应收录有两种方式，一种使用刚刚谷歌导入过去，第二种是就是自己添加 URL，方法与Google收录类似，不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 经验之谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> SEO </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟定位完成校园跑</title>
      <link href="/2024/03/07/%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D%E5%AE%8C%E6%88%90%E6%A0%A1%E5%9B%AD%E8%B7%91/"/>
      <url>/2024/03/07/%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D%E5%AE%8C%E6%88%90%E6%A0%A1%E5%9B%AD%E8%B7%91/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>对于利用定位检测的校园跑软件，使用fake location这个软件实现虚拟定位，进而达到足不出户刷校园跑。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>fake location软件：<a href="https://github.com/Lerist/FakeLocation/releases/">下载地址</a></p><p>有定位功能的root环境（root可提高成功几率）：可以是本机root/面具、带有root的模拟器、带有root的虚拟机。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>以安卓光速虚拟机为例（光速虚拟机提供免费root功能）</p><ol><li>下载光速虚拟机：<a href="https://gsxnj.cn/index/">下载地址</a></li><li><p>创建安卓7虚拟环境（初次使用按软件要求进行配置，包括进入开发者模式、无线调试等可自行百度）</p><p><img src="/创建安卓7虚拟环境.jpg" style="zoom:33%;" /></p></li><li><p>导入fake location和校园跑软件</p><p><img src="/导入.jpg" style="zoom: 80%;" /></p><p><img src="/选择导入.jpg" style="zoom:33%;" /></p><p><img src="/导入软件.jpg" alt="导入软件" style="zoom: 80%;" /></p></li><li><p>选择位置进行位置模拟（以root模式）</p><p><img src="/添加定位.jpg" alt="添加定位" style="zoom:80%;" /></p><p><img src="/选择定位.jpg" alt="选择位置" style="zoom:33%;" /></p><p><img src="/开始模拟.jpg" alt="开始模拟" style="zoom:33%;" /></p></li><li>移动摇杆进行移动（非VIP限速1m/s）</li></ol><h2 id="本校解决方案（东南大学）"><a href="#本校解决方案（东南大学）" class="headerlink" title="本校解决方案（东南大学）"></a>本校解决方案（<del>东南大学</del>）</h2><p>由于本校采用的是间隔时间进行定位采样，可以在目标线路（操场）上定位多个点，再在历史定位中间依次更换虚拟定位让系统记录。</p><h2 id="通用解决方案（提升体验）"><a href="#通用解决方案（提升体验）" class="headerlink" title="通用解决方案（提升体验）"></a>通用解决方案（提升体验）</h2><p>开VIP🤯</p><p>可获得快速摇杆，路线模拟（自动运行）等。</p><p><img src="专业版1.jpg" style="zoom: 33%;" /><img src="/专业版2.jpg" style="zoom: 33%;" /></p><h2 id="常见失败原因"><a href="#常见失败原因" class="headerlink" title="常见失败原因"></a>常见失败原因</h2><ol><li>未以root模式启动</li><li>需要启动基站模拟等增强功能</li><li>未给fake location足够权限</li><li>未给光速虚拟机足够权限</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校园跑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformer经典论文阅读后综述</title>
      <link href="/2024/02/24/Transformer%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%90%8E%E7%BB%BC%E8%BF%B0/"/>
      <url>/2024/02/24/Transformer%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%90%8E%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Transformer-in-Deep-Learning"><a href="#Transformer-in-Deep-Learning" class="headerlink" title="Transformer in Deep Learning"></a>Transformer in Deep Learning</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Transformer模型是一种革命性的神经网络架构，它在自然语言处理（NLP）和计算机视觉（CV）等多个领域都取得了卓越的成就。本论文旨在介绍Transformer模型的结构、以及在NLP领域和CV领域中的应用。深入探讨Transformer模型在不同领域之间的共同特点和差异。我们首先详细介绍了Transformer模型的核心结构，然后探讨了在NLP任务中的Transformer变种（如BERT和GPT），最后研究了Transformer在计算机视觉中的新兴应用（如Vision Transformer）。通过本文，读者将能够深入了解Transformer模型的工作原理以及它在不同领域中应用的优势和改进。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>自然语言处理（NLP）和计算机视觉（CV）一直是人工智能领域的两大关键领域。这些领域的发展一直受制于模型的性能和能力，而Transformer模型的出现冲击了RNN和CNN的统治地位。在过去的几年里，Transformer模型已经成为NLP和CV任务的首选模型之一，且具有统一NLP和CV研究方法的势头。</p><p>首先，我们将详细介绍Transformer模型的基本结构，包括自注意力机制（self-attention）。这种机制使其能够同时处理输入序列中的各个元素，无论是单词、像素还是其他形式的数据。这个思想的强大之处在于它的通用性，它使Transformer能够在各种领域中取得成功。在NLP领域，Transformer模型已在文本分类、命名实体识别和机器翻译等领域取得了巨大成功。而在计算机视觉领域，Transformer也已经在图像分类和目标检测中崭露头角。</p><p>然而，虽然Transformer模型在不同领域之间的应用非常广泛，但它在每个领域中都有自己的独特挑战和特点。例如，在NLP中，BERT模型通过让模型获得双向输入，掌握上下文信息来改善预训练词嵌入，而在CV中，ViT模型通过对图像的分块处理来应对图像数据的巨大复杂性。通过对这些异同之处的深入研究，我们可以更好地理解Transformer模型的多领域适用性，以及如何将其推向新的高度。</p><h2 id="什么是Transformer"><a href="#什么是Transformer" class="headerlink" title="什么是Transformer"></a>什么是Transformer</h2><p>Transformer是一个基于注意力机制的神经网络模型，Transformer模型由编码器和解码器组成，两者都由多个相同的层组成，每一层有两个子层：多头自注意力机制层和全连接前馈神经网络，Transformer模型利用自注意力机制捕捉输入序列中每个元素与其他元素之间的关系，利用多头机制提高模型的性能。</p><p><img src="/transformer结构.png" alt="Transformer架构" style="zoom: 67%;" /></p><p>接下来我将自下而上从输入到输出介绍transformer模型。</p><h3 id="Input-Embedding-and-Output-Embedding（输入嵌入和输出嵌入）"><a href="#Input-Embedding-and-Output-Embedding（输入嵌入和输出嵌入）" class="headerlink" title="Input Embedding and Output Embedding（输入嵌入和输出嵌入）"></a>Input Embedding and Output Embedding（输入嵌入和输出嵌入）</h3><p>Word Embedding（词嵌入）是将离散化的符号序列（如单词、字符）转换为连续的向量表示，以便使神经网络可以有效地处理文本数据。它使得模型能够理解文本数据的语义和上下文信息，并为后续的自注意力层和前馈神经网络提供了输入。</p><h3 id="Positional-Encoding（位置编码）"><a href="#Positional-Encoding（位置编码）" class="headerlink" title="Positional Encoding（位置编码）"></a>Positional Encoding（位置编码）</h3><p>由于 Transformer 不包含处理输入序列的循环或卷积操作，它不能自动地理解单词的顺序信息。因此，我们必须注入一些关于相对或绝对位置的信息序列中的标记。为此，我们引入了“位置编码”来将位置信息嵌入到模型中。位置编码是一个与位置、维度相关的矩阵，它会与输入的词嵌入相加。在原论文中，作者采用了正余弦函数来进行位置编码。</p><h3 id="Attention（注意力机制）"><a href="#Attention（注意力机制）" class="headerlink" title="Attention（注意力机制）"></a>Attention（注意力机制）</h3><p>注意力函数可以描述为将查询（query）和一组键值对（key-value pairs）映射到输出，其中查询(Q)、键(K)、值(V)和输出都是向量。 输出被计算为值的加权和，其中分配给每个值的权重是由查询(Q)与相应键(v)的兼容性函数计算的。</p><p><img src="/注意力函数.png" alt="注意力函数"></p><h4 id="Scaled-Dot-Product-Attention（缩放点积注意力）"><a href="#Scaled-Dot-Product-Attention（缩放点积注意力）" class="headerlink" title="Scaled Dot-Product Attention（缩放点积注意力）"></a>Scaled Dot-Product Attention（缩放点积注意力）</h4><p>自注意力机制（Self-attention）是 Transformer 模型的关键组成部分，它允许模型在一个序列中的不同位置之间建立权重连接，从而在一个步骤内同时考虑所有位置的信息。自注意力机制的计算分为以下几步：</p><ul><li>对于一个输入序列，首先通过三个线性变换分别得到查询(Q)、键(K)和值(V)的向量表示。这些向量用于计算注意力分数和生成权重。</li><li>计算注意力分数：为了衡量每个位置与其他位置的关联程度，通过计算查询和键之间的点积，然后进行缩放（通常使用缩放因子，如$\sqrt{d_k}$），得到注意力分数（Attention Scores）。</li><li>注意力分数的归一化（Normalization）：应用 Softmax 函数将注意力分数转化为概率分布，使得每个位置对其他位置的贡献权重为1，形成归一化的注意力权重。</li><li>加权求和：将注意力权重应用于值的向量，然后将所有加权的值进行加和，得到最终的输出。这个输出包含了所有位置的信息，但每个位置的贡献由其与其他位置的关联程度决定。</li></ul><p>自注意力机制允许模型动态地分配不同位置的权重，从而在不同任务中灵活捕获上下文信息。这是 Transformer 模型在各种自然语言处理任务中表现出色的关键之一。</p><p><img src="/自注意力机制.png" alt="自注意力机制"></p><h4 id="Multi-Head-Attention（多头注意力机制）"><a href="#Multi-Head-Attention（多头注意力机制）" class="headerlink" title="Multi-Head Attention（多头注意力机制）"></a>Multi-Head Attention（多头注意力机制）</h4><p>Transformer 中的多头注意力机制（Multi-Head Attention）是自注意力机制的扩展，允许模型在不同表示子空间中学习自注意力。这个机制增加了模型的表示能力，使其能够同时关注输入序列中的不同信息，从而更好地捕捉序列中的复杂关系。多头注意力机制通过将多个并行的自注意力机制组合在一起，每个自注意力机制都称为一个“头”。每个头有自己的一组查询、键和值参数，这些参数是通过学习而得的。将所有注意力头的输出连接在一起，并通过一个线性变换来产生最终的多头注意力输出。其优点在于提高了模型的学习能力：不同的头可以学习捕获不同的关系，从而提高了模型的表示能力。例如，一些头可以关注语法关系，而其他头可以关注语义关系。提高了训练效率：多头注意力可以并行计算，因为每个头都是独立的，这提高了模型的训练和推理效率。提高了模型稳定性：多头注意力有助于减轻注意力机制中的一些不稳定性，因为多个头的组合可以平滑化注意力权重的分布。</p><p><img src="/多头自注意力机制.png" alt="多头注意力机制"></p><h4 id="Add-amp-Norm（残差连接-amp-层归一化）"><a href="#Add-amp-Norm（残差连接-amp-层归一化）" class="headerlink" title="Add &amp; Norm（残差连接&amp;层归一化）"></a>Add &amp; Norm（残差连接&amp;层归一化）</h4><p>Transformer在每个子层（自注意力层和前馈神经网络层）的输入和输出之间，引入了残差连接和层归一化，残差连接可以通过跳过该层来传递一定量的信息，使梯度直接流过某层；层归一化把数据转化成均值为 0 方差为1的数据，保证数据特征分布的稳定性。这些方法可以帮助缓解训练过程中的梯度消失问题。</p><h4 id="Feed-Forward-Neural-Network（前馈神经网络）"><a href="#Feed-Forward-Neural-Network（前馈神经网络）" class="headerlink" title="Feed-Forward Neural Network（前馈神经网络）"></a>Feed-Forward Neural Network（前馈神经网络）</h4><p>Transformer的每个编码器和解码器层都包括一个前馈神经网络。它将自注意力层的输出映射到一个更高维度的空间，然后再映射回原始维度。这个过程包括两个线性变换和一个非线性激活函数，通常是ReLU。其作用是通过线性变换，先将数据映射到高纬度的空间再映射到低纬度的空间，提取了更深层次的特征。并且加入一定非线性变换，提高模型学习能力。</p><h4 id="Masked-Multi-Head-Attention（带掩码的多头注意力机制）"><a href="#Masked-Multi-Head-Attention（带掩码的多头注意力机制）" class="headerlink" title="Masked Multi-Head Attention（带掩码的多头注意力机制）"></a>Masked Multi-Head Attention（带掩码的多头注意力机制）</h4><p>Masked Multi-Head Attention是一种用于处理可变长度序列的重要技术。它的主要作用是在自注意力计算中，确保模型只关注当前位置之前的信息，而不会泄露未来位置的信息。在处理序列数据时，尤其是在解码器中，我们会用到掩码机制来确保生成的每个位置的信息只取决于当前位置及其之前的信息。这是因为在生成输出序列时，未来的信息是不可见的。具体来说，掩码机制会创建一个掩码矩阵，该矩阵与注意力分数相乘，将未来位置的分数置为负无穷大（或经过 softmax 后为零），从而在注意力计算中消除了未来位置的影响。这使得模型只能关注于当前位置以及之前的信息，而不关注当前位置之后的信息。</p><h3 id="Transformer的优势"><a href="#Transformer的优势" class="headerlink" title="Transformer的优势"></a>Transformer的优势</h3><ul><li>与RNN和CNN相比，Transformer具有更好的并行性：Transformer中的自注意力机制可以并行计算，而RNN和CNN中的循环结构和卷积结构需要依次计算，难以并行化。例如RNN需要从循环结构中获取序列的时间依赖关系，而CNN需要从小区域到大区域依次扩大感受野。</li><li>更好的长距离依赖建模能力：Transformer中的自注意力机制可以捕捉输入序列中任意两个位置之间的关系，而RNN只能捕捉相邻位置之间的关系，CNN只能捕捉局部区域内的关系。</li><li>更好的全局特征获取能力：Transformer中的自注意力机制可以对输入序列中每个位置进行注意力计算，从而获取全局上下文信息，而RNN和CNN只能获取局部上下文信息。鉴于Transformer相较于之前的模型有这么多优点，它很快被用在了NLP，CV等领域上。</li></ul><h2 id="Transformer-in-NLP"><a href="#Transformer-in-NLP" class="headerlink" title="Transformer in NLP"></a>Transformer in NLP</h2><p>Transformer被提出时，是被用在机器翻译上的。它帮助改善了RNN在并行性和长文本处理上的缺陷，使得机器翻译模型的准确率提高了几个百分点。当人们意识到transformer和attention在NLP上具有很多优势，便想把transformer扩展应用文本分类、语义分析、语言生成等领域。他们将transformer 与预训练结合，训练出一个模型，再通过微调去适应不同的任务。这样可以减少模型在特定任务上的训练时间和数据量，并且降低过拟合的发生模型更加准确和可靠。于是在NLP中，预训练transformer开始大行其道。</p><h3 id="Bert-Bidirectional-Encoder-Representation-from-Transformers"><a href="#Bert-Bidirectional-Encoder-Representation-from-Transformers" class="headerlink" title="Bert: :Bidirectional Encoder Representation from Transformers"></a>Bert: :Bidirectional Encoder Representation from Transformers</h3><p><img src="/bert架构.png" alt="Bert架构"></p><p>Bert 是一个预训练的语言表征模型。其主要用到了transformer 的Encoder 模块，在预训练时采用了Masked Language Model（MLM）和Next Sentence Prediction（NSP）方法，强调双向获取信息，充分利用上下文信息，提高模型的理解能力。下面我将就Bert的一些改进进行介绍。</p><h4 id="Encoder-only"><a href="#Encoder-only" class="headerlink" title="Encoder only"></a>Encoder only</h4><p>Bert作为一个特征提取器，其主要目的是进行自监督的预训练学习，学习文本的深层语义信息。因此它仅保留了transformer中的Encoder部分，并且借助Encoder不掩盖后面位置的信息的特点，Bert实现了让模型学习双向的文本信息，结合上下文进行预测。</p><h4 id="Masked-Language-Model"><a href="#Masked-Language-Model" class="headerlink" title="Masked Language Model"></a>Masked Language Model</h4><p>MLM是 BERT 模型的预训练任务之一。在 MLM 任务中，输入文本的一部分词汇会被随机遮盖，模型的任务是根据上下文来预测这些被遮盖的词汇。首先，它随机地将输入文本中的15%的词替换为一个特殊的[MASK]标记，表示这些词被遮盖了。然后，它使用一个基于Transformer的编码器来处理这个遮盖后的文本，得到每个位置的隐藏状态向量。最后，将每个位置的隐藏状态向量输入一个softmax来得到词汇表中所有词的概率分布，进而预测被覆盖的词。MLM任务使得Bert不是像之前的语言模型那样只能从左到右或者从右到左地处理文本。这对于很多自然语言处理的下游任务，如机器阅读理解，自然语言推理，问答系统等，都有很大的帮助。</p><h4 id="Next-Sentence-Prediction"><a href="#Next-Sentence-Prediction" class="headerlink" title="Next Sentence Prediction"></a>Next Sentence Prediction</h4><p>NSP也是BERT 模型的预训练任务之一。在NSP任务中，模型会输入两个句子，模型需要判断这两个句子是否具有上下文关联关系。首先，它从文本语料库中随机选择两个句子作为输入，其中第一个句子称为A，第二个句子称为B。然后，它在两个句子之间加入一个特殊的分隔符[SEP]，并在句子A的开头加入一个特殊的token [CLS]，作为整个输入序列的第一个词。接着，它使用一个基于Transformer的编码器来处理这个输入序列，得到每个位置的隐藏状态向量。最后，它使用一个二分类器来预测句子B是否在原始文档中是句子A的下一句。在训练期间，输入的句子对50％ 在原始文档中是前后关系，另外 50％ 是从语料库中随机组成的无关句子对。</p><h4 id="Improve-of-input-embeddings"><a href="#Improve-of-input-embeddings" class="headerlink" title="Improve of input embeddings"></a>Improve of input embeddings</h4><p>Bert的input embeddings相较于Transformer进行了改进，它将Position Embeddings不再由公式进行转换，而是让模型去学习如何对位置进行编码。并且Bert加入了Segment Embeddings，用来表示两个不同的句子，以匹配它的预训练任务。Bert还开创性的在input embeddings中加入了一些特殊token。如[CLS]，[SEP]，[CLS]经过自注意力机制后的输出就是模型对一整句话的注意力，即模型对句子的特征提取。因为注意力机制的特殊性，把它放在句子中的任意位置效果都相同。而[SEP]则是用来分隔不同的句子的。这些特殊字符在模型中有特殊的含义，后续的ViT模型也借鉴了这种用特殊字符的方法来提高模型的理解能力。</p><p><img src="/输入嵌入.png" alt="The input embeddings in Bert"></p><h4 id="Fine-tuning（微调）"><a href="#Fine-tuning（微调）" class="headerlink" title="Fine-tuning（微调）"></a>Fine-tuning（微调）</h4><p>前面提到，Bert本质是一个预训练的特征提取器。它将输入的句子，通过transformer的Encoder进行编码，将句子的特征提取出来。为了将这些句子特征运用到各种自然语言处理任务上，还需要对模型进行微调。比如选择特定的目标函数，将句子的哪些部分的特征作为下游任务的输入等等。在【Bert框架图】中，就具体展示了Bert如何在SQuAD数据集上进行问答任务。</p><h4 id="The-contribution-of-Bert"><a href="#The-contribution-of-Bert" class="headerlink" title="The contribution of Bert"></a>The contribution of Bert</h4><p>Bert模型的贡献在于它引入了预训练和微调体系和开创了双向语义理解的预训练任务。Bert模型只需要在大量无标注的数据上进行无监督训练，然后进行模型迁移和有监督微调，便可应用在不同的任务上。这大大减少了对特定任务的模型训练成本和大量有标注数据的需求。而双向语义理解的预训练任务则很好的提高了模型对上下文结合的理解能力。</p><h3 id="GPT-Generative-Pre-trained-Transformer"><a href="#GPT-Generative-Pre-trained-Transformer" class="headerlink" title="GPT: Generative Pre-trained Transformer"></a>GPT: Generative Pre-trained Transformer</h3><p>GPT是一种基于Transformer的生成式预训练语言模型，它可以根据给定的文本生成连贯和自然的文本，并且可以用于多种自然语言处理的任务，如机器翻译，文本摘要，问答系统等。GPT的核心思想是利用大量的无标注文本数据进行无监督的预训练，学习文本的通用表示，然后在特定的任务上进行有监督的微调，调整模型参数，提高模型性能。GPT有多个版本，如GPT-1，GPT-2，GPT-3等，每个版本都增加了模型的参数数量和训练数据的规模，从而提高了模型的生成能力和泛化能力。下面我将就GPT-1到GPT-3的一些研究论文，介绍一下GPT的特点。</p><h4 id="Decoder-only"><a href="#Decoder-only" class="headerlink" title="Decoder only"></a>Decoder only</h4><p><img src="/gpt架构.png" alt=""></p><p>GPT只使用了Transformer的Decoder部分，而没有使用Encoder部分。这是因为GPT的目标是做语言建模，即根据上文预测下一个单词。而语言建模只需要关注之前生成的文本，而不需要关注整个输入序列。因此，GPT只需要使用掩码自注意力层来实现这个功能，而不需要使用编码器-解码器注意力层。另外，GPT还去掉了Decoder中原本用来接收Encoder输出的多头自注意力层，因为GPT没有Encoder部分。GPT和Transformer Decoder的结构对比如图。</p><h4 id="GPT-2-can-be-a-zero-shot-learning-language-model"><a href="#GPT-2-can-be-a-zero-shot-learning-language-model" class="headerlink" title="GPT-2 can be a zero-shot learning language model"></a>GPT-2 can be a zero-shot learning language model</h4><p>在模型大小和训练参数量不断扩大的情况下，GPT-2做到了zero-shot learning（零样本学习）。它可以在没有任何标注数据或者参数调整的情况下，直接执行下游任务。这一点与BERT等模型不同，它们需要在预训练之后进行有监督的微调才能适应特定的任务。当GPT-2要执行一个zero-shot的下游任务时，它只需要根据任务的描述和示例来生成相应的文本。比如，如果要做机器翻译任务，你只需要输入“Translate from English to French: Hello, how are you?”，它就会输出“Bonjour, comment allez-vous?”。如果要做问答任务，你只需要输入“Who is the president of U.S.?”，它就会输出“Joseph Robinette Biden Jr.”。这些输入都可以看作是给模型的提示或者指令（prompt），让模型知道要做什么样的任务，而不需要再去给一些有标注数据让模型进行迁移学习（微调），提高了模型的性能和泛化能力。这是因为GPT-2使用了海量的无标注文本数据进行预训练，学习了通用的语言知识和规律。这些数据包含了各种任务相关的信息，比如语法，逻辑，常识等，让模型可以理解输入的自然语言的语义。GPT-2进而通过自回归的方式，从左到右地预测下一个单词，从而进行语言生成和输出。</p><h4 id="A-particularly-large-GPT-3-exhibits-emergence"><a href="#A-particularly-large-GPT-3-exhibits-emergence" class="headerlink" title="A particularly large GPT-3 exhibits emergence"></a>A particularly large GPT-3 exhibits emergence</h4><p>在GPT-2之后，OpenAI进一步的增加模型大小和训练参数量，最后在一种量变导致质变的情况下，模型的性能取得了质的飞跃，出现了Grokking（”涌现“）。例如模型的准确率和泛化性大大提高，可以通过少量的示例来完成各种下游任务。出现“涌现”的原因尚不可知，人们猜测是因为大模型具有更强的记忆和推理能力，能够从海量的数据中学习到更多的知识和规律。总之在该论文中，GPT-3在参数量提升到1750亿的情况下，模型的能力刷新了很多当时NLP领域的记录。并且论文指出，GPT模型还未见到增加参数量带来的性能饱和现象，这说明继续增加参数量和原始数据，GPT的性能还能进一步的提升。</p><h4 id="Where-to-get-so-much-text-data"><a href="#Where-to-get-so-much-text-data" class="headerlink" title="Where to get so much text data"></a>Where to get so much text data</h4><p>GPT需要大量的文本数据用来学习，如何获得高质量的文本数据也是一个值得研究的方向。OpenAI在GPT-2中使用了一个国外论坛Reddit的数据，并借助Reddit的点赞机制，筛选优质数据。而GPT-3训练所用的数据量又翻了1125倍，来到了45TB，相当于互联网上所有文本的10%。GPT-3借助Common Crawl从互联网爬取的超大数据集，并将Common Crawl进行筛选过滤。其过滤算法是借助GPT-2已筛选好的优质文本作为正例训练LR分类器，用来筛选数据。再通过去重等方法得到优质数据集。</p><h3 id="The-Advantages-of-Pre-trained-Transformer-in-NLP"><a href="#The-Advantages-of-Pre-trained-Transformer-in-NLP" class="headerlink" title="The Advantages of Pre-trained Transformer in NLP"></a>The Advantages of Pre-trained Transformer in NLP</h3><p>由上文可知Transformer预训练模型可以充分利用大规模的无标注文本数据，通过自监督学习的方式，学习到通用的语言知识和表示，从而提高下游任务的性能和泛化能力。并且Transformer预训练模型具有很好的可扩展性和灵活性，可以根据不同的任务需求，调整模型的结构和参数，实现多种功能和应用。Transformer预训练模型是目前NLP领域最先进和最流行的技术之一，它已经在机器翻译、文本分类、阅读理解、对话生成、文本摘要等多个任务上取得了显著的效果，展现了巨大的潜力和前景。</p><h2 id="Transformer-in-CV"><a href="#Transformer-in-CV" class="headerlink" title="Transformer in CV"></a>Transformer in CV</h2><p>在CV领域，transformer也在大放异彩。一开始，人们将transformer中的attention与CNN结合，将attention用于CNN中的特征提取。后来Vision Transformer这篇论文提出，用纯的transformer结构进行预训练，训练出来的模型同样具有很好的效果。</p><p><img src="/ViT架构.png" alt="ViT架构"></p><h3 id="How-to-enter-the-image-into-the-Transformer"><a href="#How-to-enter-the-image-into-the-Transformer" class="headerlink" title="How to enter the image into the Transformer"></a>How to enter the image into the Transformer</h3><p>如何将二维的图片转化为一维的序列输入transformer是想要在CV中利用transformer的第一步。这篇论文展示了一种巧妙的方法。即将图片分为一个个patch，将patchs排成一维序列输入transformer便达到了类似NLP中输入一句话的效果。这也是论文表示为什么说AN IMAGE IS WORTH 16X16 WORDS 的原因。至于为什么不将图片的每个像素分割拉直成一维，那是以为这样处理后的序列将会变得很长，增加了模型训练的复杂度。</p><h3 id="Patch-and-Position-Embedding"><a href="#Patch-and-Position-Embedding" class="headerlink" title="Patch and Position Embedding"></a>Patch and Position Embedding</h3><p>将图片分割成一个个patch之后势必会损失图片的某些位置信息。不过好在transformer模型本身就提供了一个Position Embedding，这使得Patch Embedding后的向量可以再加上一个Position Embedding来表示该patch在图片中的位置信息。ViT模型主要借鉴的是前面所说的Bert模型，它在Position Embedding的具体转换方法上同样交给模型去自主学习。</p><h3 id="Extra-learnable-class-embedding"><a href="#Extra-learnable-class-embedding" class="headerlink" title="Extra learnable [class] embedding"></a>Extra learnable [class] embedding</h3><p>在ViT中作者加入了一个额外的可学习的嵌入向量，它用于表示整个图像的类别信息，即ViT架构图中的“0*”。它的目的是从其他图像块的嵌入向量中学习到全局的特征，作为图像的表示向量。这类似Bert模型中的[CLS]token，都是用于获取整个序列的信息。</p><h3 id="Compared-with-CNN"><a href="#Compared-with-CNN" class="headerlink" title="Compared with CNN"></a>Compared with CNN</h3><p>相比于CNN，ViT有一些常见的优点，例如利用无标注数据的能力，更好的并行性，泛化能力更强，鲁棒性更好。这些优点有些也来自transformer模型，在前文中已提及，这里就不再展开。而ViT也不仅仅都是优点，当训练数据集不够大的时候，ViT的表现通常比同等大小的ResNets要差一些，这是因为CNN在CV领域已经得到了成熟的应用，利用transformer难以使用CNN的一些先验知识，如locality/two-dimensional neighborhood structure（图片的二维关系）和translation equivariance（平移不变性）。但当数据集不断扩大时，ViT在多项任务上的性能反超了ResNets。在论文中，作者也提到了将ResNets与transformer结合进行训练（Hybrid），即在图片Embedding时借助ResNets，将图片转化为向量。Hybrid在小数据集上的表现均好于ViT和ResNets，但在大数据集上与却差于ViT。这说明Transformer在CV领域也有取代CNN的势头。</p><p><img src="/模型能力对比图.png" alt="模型性能比较"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在阅读了大量的关于transformer论文后，我们不难发现transformer在广度上不断扩展，从提出之时的机器翻译到NLP整个领域再到CV等其他深度学习的领域，transformer被应用在各种不同的任务中，或与传统RNN和CNN结合，或直接开辟一条新的方法，为不同领域不同任务的解决提供了更多的选择。而在深度上，从时间线上来看，transformer模型也在不断的改善和调整来适应不同的任务。包括在数据量和模型参数量上的不断扩大，将预训练和微调的思想加入transformer，这些研究都在不断的提高transformer模型的学习能力和泛化能力。</p><p>下面我列举一下transformer模型目前在哪些领域已取得了比较大的成功</p><ul><li>自然语言处理： Transformer 及其变体已在 NLP 任务中得到广泛探索和应用，例如机器翻译、语言建模和命名实体识别。大量的努力致力于在大规模文本语料库上预训练 Transformer 模型，这是 Transformer 在 NLP 中广泛应用的主要原因之一。</li><li>计算机视觉： Transformer 还适用于各种视觉任务，例如图像分类、物体检测、图像生成和视频处理。</li><li>音频应用： Transformer 还可以扩展到与音频相关的应用，例如语音识别，语音合成，语音增强和音乐生成 。</li><li>多模态应用：由于其灵活的架构，Transformer 还被应用于各种多模态场景，例如视觉问答、视觉常识推理、字幕生成、语音到文本翻译和文本到图像生成。</li></ul><h3 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h3><p>目前关于transformer的研究的应用仍在不断发展。例如在CV领域的swim transformer模型基于ViT模型进行改进，它的主要特点是使用滑动窗口机制，将图像分成多个小块，然后在每个小块内进行自注意力计算，这样可以降低计算复杂度，同时也保留了局部信息。除此之外，Transformer打破NLP和CV研究的鸿沟，为多模态的应用带来了希望。如今我们已经可以用上很多基于Transformer的多模态的应用，例如通过语言描述生成代码、图片、视频、音乐等等，这些应用极大的促进了AIGC，AGI的发展。</p><p>因此在未来的研究中，我们可以进一步改进Transformer，如对Transformer优秀的性能进行理论分析；对Transformer的学习和生成过程进行解释，减少黑箱性；对Transformer的模内和跨模态注意力的设计进行改进。</p><p>相信在众多的研究者的努力下，Transformer的能力可以得到进一步的发展，Transformer可以被运用到更多的领域上，更好的改善我们的生活。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>[1] A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez, Ł. Kaiser, and I. Polosukhin,  “Attention is all you need,” <em>Advances in neural information processing systems</em>, vol.30, 2017.</li><li>[2] J. Devlin, M.-W. Chang, K. Lee, and K. Toutanova, “Bert: Pre-training of deep bidirectional transformers for language understanding,” <em>arXiv preprint arXiv:1810.04805</em>, 2018.</li><li>[3] A. Dosovitskiy, L. Beyer, A. Kolesnikov, D. Weissenborn, X. Zhai, T. Unterthiner, M. Dehghani, M. Minderer, G. Heigold, S. Gelly <em>et al.</em>, “An image is worth 16x16 words: Transformers for image recognition at scale,” <em>arXiv preprint arXiv:2010.11929</em>, 2020.</li><li>[4] A. Radford, K. Narasimhan, T. Salimans, I. Sutskever <em>et al.</em>, “Improving language understanding by generative pre-training,” 2018.</li><li>[5] A. Radford, J. Wu, R. Child, D. Luan, D. Amodei, I. Sutskever <em>et al.</em>, “Language models are unsupervised multitask learners,” <em>OpenAI blog</em>, vol.1, no.8, p.9, 2019.</li><li>[6] T. Brown, B. Mann, N. Ryder, M. Subbiah, J. D. Kaplan, P. Dhariwal, A. Neelakantan, P. Shyam, G. Sastry, A. Askell <em>et al.</em>, “Language models are few-shot learners,” <em>Advances in neural information processing systems</em>, vol.33, pp.1877–1901, 2020.</li><li>[7] B. McCann, N. S. Keskar, C. Xiong, and R. Socher, “The natural language decathlon: Multitask learning as question answering,” <em>arXiv preprint arXiv:1806.08730</em>, 2018.</li><li>[8] N. Parmar, A. Vaswani, J. Uszkoreit, L. Kaiser, N. Shazeer, A. Ku, and D. Tran, “Image transformer,”  <em>International conference on machine learning</em>. PMLR, pp.4055–4064, 2018.</li><li>[9] T. Lin, Y. Wang, X. Liu, and X. Qiu, “A survey of transformers,” <em>AI Open</em>,2022.</li><li>[10] Z. Liu, Y. Lin, Y. Cao, H. Hu, Y. Wei, Z. Zhang, S. Lin, and B. Guo, “Swin transformer: Hierarchical vision transformer using shifted windows,” <em>Proceedings of the IEEE/CVF international conference on computer vision</em>, 2021, pp.10012–10022.</li><li>[11] A. Radford, J. W. Kim, C. Hallacy, A. Ramesh, G. Goh, S. Agarwal, G. Sastry, A. Askell, P. Mishkin, J. Clark <em>et al.</em>, “Learning transferable visual models from natural language supervision,” <em>International conference on machine learning</em>. PMLR, pp. 8748–8763, 2021.</li><li>[12] H. Chefer, S. Gur, and L. Wolf, “Transformer interpretability beyond attention visualization,” <em>Proceedings of the IEEE/CVF conference on computer vision and pattern recognition</em>, pp.782–791, 2021.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> Transformer </tag>
            
            <tag> 综述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo与Typora插入图片的解决方法</title>
      <link href="/2024/02/14/hexo%E4%B8%8ETypora%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2024/02/14/hexo%E4%B8%8ETypora%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>众所周知，在md文件中插入图片的语法为 <code>![]()</code>。</p><p>其中<strong>方括号</strong>是图片描述，<strong>圆括号</strong>是图片路径。</p><p>一般来说有三种图片路径，分别是<strong>相对路径，绝对路径和网络路径</strong>。</p><h2 id="网络路径（图床）"><a href="#网络路径（图床）" class="headerlink" title="网络路径（图床）"></a>网络路径（图床）</h2><p>所谓的网络路径就是直接引用网上的图片，直接复制图片的网络地址，放在圆括号中就完事了。</p><p>这种方式十分的方便，但是也存在一定的问题：</p><ul><li>图片失效导致无法加载；</li><li>打开网页后要再请求加载图片；</li><li>原网站限制，如微信公众号的图片会变得不可见等。</li></ul><h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>绝对路径是图片在计算机中的绝对位置。</p><h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>相对路径是相对于当前文件的路径。</p><p>当采用相对路径时，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>/source/images</code> 文件夹中。然后通过类似于 <code>![图片描述](/images/image.jpg)</code> 的方法访问它们。</p><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。你需要将 <code>_config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开<strong>文章资源文件夹</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹在 <code>/source/_posts</code>文件夹中。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p><p>例如新建一个博客名为 <code>1.md</code>，相应的会生成一个 <code>1</code>文件夹，在该文件夹中存放图片 <code>image.jpg</code>。<br>在Typora编辑器中打开 <code>1.md</code>，使用 <code>![](1/image.jpg)</code>能在编辑器中正常引用该图片。<br>在hexo网页中，却无法使用 <code>![]()</code>的相对路径的方法进行引用，本人尝试了很多种相对路径的写法都无法实现。<br>原因可能是 <code>_posts</code>文件夹中的文件在构建html时，其中的图片地址会发生改变，如果图片放在 <code>/source/其他文件夹</code>中，图片正常显示。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>此时如果要插入该图片，可以用以下几种方法：</p><h2 id="使用相对路径引用的标签插件"><a href="#使用相对路径引用的标签插件" class="headerlink" title="使用相对路径引用的标签插件"></a>使用相对路径引用的标签插件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>正确的引用该图片方式是使用下列的标签插件：</p><p><code>&#123;% asset_img image.jpg This is an image %&#125;</code></p><h2 id="使用-hexo-asset-image-hexo-asset-img插件"><a href="#使用-hexo-asset-image-hexo-asset-img插件" class="headerlink" title="使用 hexo-asset-image/hexo-asset-img插件"></a>使用 <code>hexo-asset-image</code>/<code>hexo-asset-img</code>插件</h2><p>（较为复杂，本人尝试未成功，可自行搜索）</p><h2 id="使用hexo-renderer-marked插件（推荐）"><a href="#使用hexo-renderer-marked插件（推荐）" class="headerlink" title="使用hexo-renderer-marked插件（推荐）"></a>使用<a href="https://github.com/hexojs/hexo-renderer-marked"><code>hexo-renderer-marked</code></a>插件（推荐）</h2><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><p>用 <code>npm install hexo-renderer-marked</code>命令安装（新版hexo已集成，无需安装）</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>在 <code>_config.yml</code>中更改配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><p>第一行在前文已修改，后三行需要自行添加到第一行后。<br>此时在hexo网页中，使用 <code>![](/image.jpg)</code>的相对路径的方法可成功进行引用。<br>（注意：路径中不能有空格）</p><h1 id="方法完善"><a href="#方法完善" class="headerlink" title="方法完善"></a>方法完善</h1><p>注意到，如果使用 <code>![](/image.jpg)</code>的相对路径在typora本地无法正确引用图片（typora需要使用 <code>![](1/image.jpg)</code>）<br>在文章的front-matter中添加一行 <code>typora-root-url: 文章标题</code>。那么在typora中所有的路径前都会加上 <code>文章标题/</code>。（<code>image.jpg-&gt;1/image.jpg</code>）<br>进一步可以在 <code>scaffolds</code>文件夹中的文章模板中添加 <code>typora-root-url: &#123;&#123;title&#125;&#125;</code>这样每次执行 <code>hexo new</code>命令新建文章的时候，会在front-matter中自动添加该配置。</p><h1 id="hexo与Typora的进一步联动"><a href="#hexo与Typora的进一步联动" class="headerlink" title="hexo与Typora的进一步联动"></a>hexo与Typora的进一步联动</h1><p>文章资源文件夹中引用图片，<strong>前提是先将图片放入到文章资源文件夹</strong>，如果图片数量众多的话，一张一张的放很影响效率。<br>使用Typora可以在复制图片到文章中时，自动将图片复制到指定文件夹，并修改成对应的路径。</p><h2 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h2><p>找到Typora的偏好设置-&gt;图像，进行如下设置</p><p><img src="/屏幕截图.png" alt=""></p><p><code>./$&#123;filename&#125;</code>设置与hexo的文章资源文件夹设置相对应，<strong>至此写博客时插入图片只需将图片复制（拖动）到文章中即可。</strong></p><h1 id="实际工作流"><a href="#实际工作流" class="headerlink" title="实际工作流"></a>实际工作流</h1><p>方法一：使用 <code>hexo new &lt;layout&gt; &quot;filename&quot;</code>指令生成md文件（同时生成资源文件夹），然后使用typora打开md文件进行书写。</p><p>方法二：在 <code>/source/_posts</code>新建md文件，然后使用typora打开md文件进行书写，在插入图片时会自动生成资源文件夹。</p>]]></content>
      
      
      <categories>
          
          <category> 经验之谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> Typora </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git教程</title>
      <link href="/2024/02/14/Git%E6%95%99%E7%A8%8B/"/>
      <url>/2024/02/14/Git%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-分布式版本控制工具"><a href="#Git-分布式版本控制工具" class="headerlink" title="Git - 分布式版本控制工具"></a>Git - 分布式版本控制工具</h1><p>教程视频：<a href="https://www.bilibili.com/video/BV1MU4y1Y7h5">https://www.bilibili.com/video/BV1MU4y1Y7h5</a></p><h2 id="1、目标"><a href="#1、目标" class="headerlink" title="1、目标"></a>1、目标</h2><ul><li>了解Git基本概念</li><li>能够概述Git工作流程</li><li>能够使用Git常用命令</li><li>熟悉Git代码托管服务</li><li>能够使用IDEA操作Git</li></ul><h2 id="2、概述"><a href="#2、概述" class="headerlink" title="2、概述"></a>2、概述</h2><h3 id="2-1、开发中的实际场景"><a href="#2-1、开发中的实际场景" class="headerlink" title="2.1、开发中的实际场景"></a>2.1、开发中的实际场景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">场景一：备份</span><br><span class="line">小明负责的模块就要完成了，就在即将Release之前的一瞬间，电脑突然蓝屏，硬盘光荣牺牲！几个月来的努力付之东流</span><br><span class="line"></span><br><span class="line">场景二：代码还原</span><br><span class="line">这个项目中需要一个很复杂的功能，老王摸索了一个星期终于有眉目了，可是这被改得面目全非的代码已经回不到从前了。什么地方能买到哆啦A梦的时光机啊？</span><br><span class="line"></span><br><span class="line">场景三：协同开发</span><br><span class="line">小刚和小强先后从文件服务器上下载了同一个文件：Analysis.java。小刚在Analysis.java文件中的第30行声明了一个方法，叫count()，先保存到了文件服务器上；小强在Analysis.java文件中的第50行声明了一个方法，叫sum()，也随后保存到了文件服务器上，于是，count()方法就只存在于小刚的记忆中了</span><br><span class="line"></span><br><span class="line">场景四：追溯问题代码的编写人和编写时间！</span><br><span class="line">老王是另一位项目经理，每次因为项目进度挨骂之后，他都不知道该扣哪个程序员的工资！就拿这次来说吧，有个Bug调试了30多个小时才知道是因为相关属性没有在应用初始化时赋值！可是二胖、王东、刘流和正经牛都不承认是自己干的！</span><br></pre></td></tr></table></figure><h3 id="2-2、版本控制器的方式"><a href="#2-2、版本控制器的方式" class="headerlink" title="2.2、版本控制器的方式"></a>2.2、版本控制器的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a、集中式版本控制工具</span><br><span class="line">集中式版本控制工具，版本库是集中存放在中央服务器的，team里每个人work时从中央服务器下载代码，是必须联网才能工作，局域网或互联网。个人修改后然后提交到中央版本库。</span><br><span class="line">举例：SVN和CVS</span><br><span class="line">b、分布式版本控制工具</span><br><span class="line">分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样工作的时候，无需要联网了，因为版本库就在你自己的电脑上。多人协作只需要各自的修改推送给对方，就能互相看到对方的修改了。</span><br><span class="line">举例：Git</span><br></pre></td></tr></table></figure><h3 id="2-3、SVN"><a href="#2-3、SVN" class="headerlink" title="2.3、SVN"></a>2.3、SVN</h3><p><img src="/SVN.png" alt="SVN"></p><h3 id="2-4、Git"><a href="#2-4、Git" class="headerlink" title="2.4、Git"></a>2.4、Git</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git是分布式的,Git不需要有中心服务器，我们每台电脑拥有的东西都是一样的。我们使用Git并且有个中心服务器，仅仅是为了方便交换大家的修改，但是这个服务器的地位和我们每个人的PC是一样的。我们可以把它当做一个开发者的pc就可以就是为了大家代码容易交流不关机用的。没有它大家一样可以工作，只不过“交换”修改不方便而已。</span><br><span class="line">git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git是Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</span><br><span class="line">同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</span><br><span class="line">到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</span><br><span class="line"> 速度</span><br><span class="line"> 简单的设计</span><br><span class="line"> 对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</span><br><span class="line"> 完全分布式</span><br><span class="line"> 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</span><br></pre></td></tr></table></figure><p><img src="Git.png" alt="Git"  /></p><h3 id="2-5、Git工作流程图"><a href="#2-5、Git工作流程图" class="headerlink" title="2.5、Git工作流程图"></a>2.5、Git工作流程图</h3><p><img src="Git工作流程图.png" alt="Git工作流程图"  /></p><p>命令如下：</p><ol><li>clone（克隆）: 从远程仓库中克隆代码到本地仓库</li><li>checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订</li><li>add（添加）: 在提交前先将代码提交到暂存区</li><li>commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本</li><li>fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li><li>pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge</li><li>push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</li></ol><h2 id="3、Git安装与常用命令"><a href="#3、Git安装与常用命令" class="headerlink" title="3、Git安装与常用命令"></a>3、Git安装与常用命令</h2><p>本教程里的git命令例子都是在Git Bash中演示的，会用到一些基本的linux命令，在此为大家提前列举：</p><ul><li><code>ls</code>/<code>ll</code> 查看当前目录</li><li><code>cat</code> 查看文件内容</li><li><code>touch</code> 创建文件</li><li><code>vi</code> vi编辑器（使用vi编辑器是为了方便展示效果，学员可以记事本、EditPlus、NotePad++等其它编辑器）</li></ul><h3 id="3-1、-Git环境配置"><a href="#3-1、-Git环境配置" class="headerlink" title="3.1、 Git环境配置"></a>3.1、 Git环境配置</h3><h4 id="3-1-1-下载与安装"><a href="#3-1-1-下载与安装" class="headerlink" title="3.1.1 下载与安装"></a>3.1.1 下载与安装</h4><p>下载地址： <a href="https://git-scm.com/download">https://git-scm.com/download</a></p><p><img src="Git下载与安装.png" alt="Git下载与安装"  /></p><p>下载完成后可以得到如下安装文件：</p><p><img src="/Git安装包.png" alt="Git安装包"></p><p>双击下载的安装文件来安装Git。安装完成后在电脑桌面（也可以是其他目录)点击右键，如果能够看到如下两个菜单则说明Git安装成功。</p><p><img src="Git右键菜单.png" alt="Git右键菜单"  /></p><p>备注：</p><p>Git GUI：Git提供的图形界面工具</p><p>Git Bash：Git提供的命令行工具</p><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><h4 id="3-1-2基本配置"><a href="#3-1-2基本配置" class="headerlink" title="3.1.2基本配置"></a>3.1.2基本配置</h4><ol><li>打开Git Bash</li><li>设置用户信息<br><code>git config --global user.name “itcast”</code><br><code>git config --global user.email “hello@itcast.cn”</code></li></ol><p>查看配置信息<br><code>git config --global user.name</code><br><code>git config --global user.email</code></p><h4 id="3-1-3-为常用指令配置别名（可选）"><a href="#3-1-3-为常用指令配置别名（可选）" class="headerlink" title="3.1.3 为常用指令配置别名（可选）"></a>3.1.3 为常用指令配置别名（可选）</h4><p>有些常用的指令参数非常多，每次都要输入好多参数，我们可以使用别名。</p><ol><li>打开用户目录，创建 <code>.bashrc</code>文件 <code>touch .bashrc</code><br>部分windows系统不允许用户创建点号开头的文件，可以打开gitBash,执行 <code>touch ~/.bashrc</code><br><code>&lt;img src=&quot;创建bashrc.png&quot; alt=&quot;创建bashrc&quot;  /&gt;</code></li><li><p>在 <code>.bashrc</code>文件中输入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用于输出git提交日志</span></span><br><span class="line">alias git-log=&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用于输出当前目录所有文件及基本信息</span></span><br><span class="line">alias ll=&#x27;ls -al&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用于一次性暂存并提交所有修改和删除的文件</span></span><br><span class="line">alias commit=&#x27;git commit -a&#x27;</span><br></pre></td></tr></table></figure></li><li>打开gitBash，执行 <code>source ~/.bashrc</code><br><code>&lt;img src=&quot;bashrc.png&quot; alt=&quot;bashrc&quot;  /&gt;</code></li></ol><h4 id="3-1-4-解决GitBash乱码问题"><a href="#3-1-4-解决GitBash乱码问题" class="headerlink" title="3.1.4 解决GitBash乱码问题"></a>3.1.4 解决GitBash乱码问题</h4><ol><li><p>打开GitBash执行下面命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure></li><li><p><code>$&#123;git_home&#125;/etc/bash.bashrc</code>文件最后加入下面两行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LANG=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">export LC_ALL=&quot;zh_CN.UTF-8&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2、获取本地仓库"><a href="#3-2、获取本地仓库" class="headerlink" title="3.2、获取本地仓库"></a>3.2、获取本地仓库</h3><p>要使用Git对我们的代码进行版本控制，首先需要获得本地仓库<br>1）在电脑的任意位置创建一个空目录（例如test）作为我们的本地Git仓库<br>2）进入这个目录中，点击右键打开Git bash窗口<br>3）执行命令 <code>git init</code><br>4）如果创建成功后可在文件夹下看到隐藏的.git目录。</p><p><img src="获取本地仓库.png" alt="获取本地仓库"  /></p><h3 id="3-3、基础操作指令"><a href="#3-3、基础操作指令" class="headerlink" title="3.3、基础操作指令"></a>3.3、基础操作指令</h3><p>Git工作目录下对于文件的<strong>修改</strong>（增加、删除、更新）会存在几个状态，这些修改的状态会随着我们执行Git的命令而发生变化。</p><p><img src="基础操作指令.png" alt="基础操作指令"  /></p><p>本章节主要讲解如何使用命令来控制这些状态之间的转换：</p><ol><li>git add (工作区 —&gt; 暂存区)</li><li>git commit (暂存区 —&gt; 本地仓库)</li></ol><h4 id="3-3-1、-查看修改的状态-status"><a href="#3-3-1、-查看修改的状态-status" class="headerlink" title="3.3.1、*查看修改的状态(status)"></a>3.3.1、*查看修改的状态(status)</h4><ul><li>作用：查看的修改的状态（暂存区、工作区）</li><li>命令形式：<code>git status</code></li></ul><h4 id="3-3-2、-添加工作区到暂存区-add"><a href="#3-3-2、-添加工作区到暂存区-add" class="headerlink" title="3.3.2、*添加工作区到暂存区(add)"></a>3.3.2、*添加工作区到暂存区(add)</h4><ul><li>作用：添加工作区一个或多个文件的修改到暂存区</li><li>命令形式：<code>git add 单个文件名|通配符</code><ul><li>将所有修改加入暂存区：<code>git add .</code></li></ul></li></ul><h4 id="3-3-3、-提交暂存区到本地仓库-commit"><a href="#3-3-3、-提交暂存区到本地仓库-commit" class="headerlink" title="3.3.3、*提交暂存区到本地仓库(commit)"></a>3.3.3、*提交暂存区到本地仓库(commit)</h4><ul><li>作用：提交暂存区内容到本地仓库的当前分支</li><li>命令形式：<code>git commit -m &#39;注释内容&#39;</code></li></ul><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><ul><li>命令形式：<code>git commit [options]</code><ul><li>options<ul><li><code>-a</code> = <code>--all</code><br>automatically stage files that have been <strong>modified and deleted</strong>.<br>（新创建的文件仍需 <code>git add</code>）</li></ul></li></ul></li></ul><h4 id="3-3-4、-查看提交日志-log"><a href="#3-3-4、-查看提交日志-log" class="headerlink" title="3.3.4、*查看提交日志(log)"></a>3.3.4、*查看提交日志(log)</h4><p><strong>在<a href="#3.1.3 为常用指令配置别名（可选）">3.1.3</a>中配置的别名 <code>git-log</code>就包含了这些参数，所以后续可以直接使用指令 <code>git-log</code></strong></p><ul><li>作用:查看提交记录</li><li>命令形式：<code>git log [option]</code><ul><li>options<ul><li><code>--all</code> 显示所有分支</li><li><code>--pretty=oneline</code> 将提交信息显示为一行</li><li><code>--abbrev-commit</code> 使得输出的commitID更简短</li><li><code>--graph</code> 以图的形式显示</li></ul></li></ul></li></ul><h4 id="3-3-5、版本回退"><a href="#3-3-5、版本回退" class="headerlink" title="3.3.5、版本回退"></a>3.3.5、版本回退</h4><ul><li>作用：版本切换</li><li>命令形式：<code>git reset --hard commitID</code><ul><li>commitID 可以使用 <code>git-log</code>或 <code>git log</code>指令查看</li></ul></li><li>如何查看已经删除的记录？<ul><li><code>git reflog</code></li><li>这个指令可以看到已经删除的提交记录</li></ul></li></ul><h4 id="3-3-6、添加文件至忽略列表"><a href="#3-3-6、添加文件至忽略列表" class="headerlink" title="3.3.6、添加文件至忽略列表"></a>3.3.6、添加文件至忽略列表</h4><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 <code>.gitignore</code>的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">no .a files</span></span><br><span class="line">*.a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">but <span class="keyword">do</span> track lib.a, even though you<span class="string">&#x27;re ignoring .a files above</span></span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">only ignore the &#x27;</span>TODO<span class="string">&#x27; file in the current directory, not subdir/TODO</span></span></span><br><span class="line">/TODO</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">ignore all files in the &#x27;</span>build/<span class="string">&#x27; directory</span></span></span><br><span class="line">build/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">ignore doc/notes.txt, but not doc/server/arch.txt</span></span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">ignore all .pdf files in the doc/ directory</span></span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h4 id="练习-基础操作"><a href="#练习-基础操作" class="headerlink" title="练习:基础操作"></a>练习:基础操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################仓库初始化######################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建目录（git_test01）并在目录下打开gitbash</span></span><br><span class="line">略</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化git仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################创建文件并提交#####################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目录下创建文件 file01.txt</span></span><br><span class="line">略</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将修改加入暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将修改提交到本地仓库，提交记录内容为：commit 001</span></span><br><span class="line">git commit -m &#x27;commit 001&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">git log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###################修改文件并提交######################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改file01的内容为：count=1</span></span><br><span class="line">略</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将修改加入暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># 将修改提交到本地仓库，提交记录内容为：update file01</span></span></span><br><span class="line">git commit -m &#x27;update file01&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">git log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以精简的方式显示提交记录</span></span><br><span class="line">git-log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###################将最后一次修改还原##################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看提交记录</span></span><br><span class="line">git-log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到倒数第2次提交的commitID</span></span><br><span class="line">略</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">版本回退</span></span><br><span class="line">git reset commitID --hard</span><br></pre></td></tr></table></figure><h3 id="3-4、分支"><a href="#3-4、分支" class="headerlink" title="3.4、分支"></a>3.4、分支</h3><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p><h4 id="3-4-1、查看本地分支"><a href="#3-4-1、查看本地分支" class="headerlink" title="3.4.1、查看本地分支"></a>3.4.1、查看本地分支</h4><ul><li>命令：<code>git branch</code></li></ul><h4 id="3-4-2、创建本地分支"><a href="#3-4-2、创建本地分支" class="headerlink" title="3.4.2、创建本地分支"></a>3.4.2、创建本地分支</h4><ul><li>命令：<code>git branch 分支名</code></li></ul><h4 id="3-4-4、-切换分支-checkout"><a href="#3-4-4、-切换分支-checkout" class="headerlink" title="3.4.4、*切换分支(checkout)"></a>3.4.4、*切换分支(checkout)</h4><ul><li>命令：<code>git checkout 分支名</code></li></ul><p>我们还可以直接切换到一个不存在的分支（创建并切换）</p><ul><li>命令：<code>git checkout -b 分支名</code></li></ul><h4 id="3-4-6、-合并分支-merge"><a href="#3-4-6、-合并分支-merge" class="headerlink" title="3.4.6、*合并分支(merge)"></a>3.4.6、*合并分支(merge)</h4><p>一个分支（合并分支）上的提交可以合并到另一个分支（目标分支）</p><ul><li>需要先切换到目标分支：<code>git checkout 目标分支名</code></li><li>合并命令：<code>git merge 合并分支名</code></li></ul><h4 id="3-4-7、删除分支"><a href="#3-4-7、删除分支" class="headerlink" title="3.4.7、删除分支"></a>3.4.7、删除分支</h4><p><strong>不能删除当前分支，只能删除其他分支</strong></p><ul><li><code>git branch -d 分支名</code> 删除分支时，需要做各种检查</li><li><code>git branch -D 分支名</code> 不做任何检查，强制删除</li><li>E.g.<br><img src="/删除分支.png" alt="删除分支"></li></ul><h4 id="3-4-8、解决冲突"><a href="#3-4-8、解决冲突" class="headerlink" title="3.4.8、解决冲突"></a>3.4.8、解决冲突</h4><p>当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：</p><ol><li>处理文件中冲突的地方</li><li>将解决完冲突的文件加入暂存区(add)</li><li>提交到仓库(commit)</li></ol><p>冲突部分的内容处理如下所示：</p><p><img src="/冲突处理.png" alt="冲突处理.png"></p><h4 id="3-4-9、开发中分支使用原则与流程"><a href="#3-4-9、开发中分支使用原则与流程" class="headerlink" title="3.4.9、开发中分支使用原则与流程"></a>3.4.9、开发中分支使用原则与流程</h4><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p><p>在开发中，一般有如下分支使用原则与流程：</p><ul><li>master （生产） 分支<br>线上分支，主分支，中小规模项目作为线上运行的应用对应的分支。</li><li>develop（开发）分支<br>是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线。</li><li>feature/xxxx分支<br>从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到develop分支。</li><li>hotfix/xxxx分支，<br>从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、develop分支。</li><li>还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等等。</li><li><img src="分支.png" alt="分支"  /></li></ul><h4 id="练习-分支操作"><a href="#练习-分支操作" class="headerlink" title="练习:分支操作"></a>练习:分支操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################创建并切换到dev01分支，在dev01分支提交</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[master]创建分支dev01</span></span><br><span class="line">git branch dev01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[master]切换到dev01</span></span><br><span class="line">git checkout dev01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[dev01]创建文件file02.txt</span></span><br><span class="line">略</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[dev01]将修改加入暂存区并提交到仓库,提交记录内容为：add file02 on dev</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;add file02 on dev&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[dev01]以精简的方式显示提交记录</span></span><br><span class="line">git-log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################切换到master分支，将dev01合并到master分支</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[dev01]切换到master分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[master]合并dev01到master分支</span></span><br><span class="line">git merge dev01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[master]以精简的方式显示提交记录</span></span><br><span class="line">git-log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[master]查看文件变化(目录下也出现了file02.txt)</span></span><br><span class="line">略</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#########################删除dev01分支</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[master]删除dev01分支</span></span><br><span class="line">git branch -d dev01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[master]以精简的方式显示提交记录</span></span><br><span class="line">git-log</span><br></pre></td></tr></table></figure><h2 id="4、Git远程仓库"><a href="#4、Git远程仓库" class="headerlink" title="4、Git远程仓库"></a>4、Git远程仓库</h2><h3 id="4-1、-常用的托管服务-远程仓库"><a href="#4-1、-常用的托管服务-远程仓库" class="headerlink" title="4.1、 常用的托管服务[远程仓库]"></a>4.1、 常用的托管服务[远程仓库]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前面我们已经知道了Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</span><br><span class="line">gitHub（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub</span><br><span class="line">码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快</span><br><span class="line">GitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。</span><br></pre></td></tr></table></figure><h3 id="4-2、-注册码云"><a href="#4-2、-注册码云" class="headerlink" title="4.2、 注册码云"></a>4.2、 注册码云</h3><p>要想使用码云的相关服务，需要注册账号（地址： <a href="https://gitee.com/signup">https://gitee.com/signup</a> ）</p><p><img src="注册码云.png" alt="注册码云"  /></p><h3 id="4-3、-创建远程仓库"><a href="#4-3、-创建远程仓库" class="headerlink" title="4.3、 创建远程仓库"></a>4.3、 创建远程仓库</h3><p><img src="创建远程仓库.png" alt="创建远程仓库"  /></p><p>仓库创建完成后可以看到仓库地址，如下图所示:</p><p><img src="仓库地址.png" alt="仓库地址"  /></p><h3 id="4-4、配置SSH公钥"><a href="#4-4、配置SSH公钥" class="headerlink" title="4.4、配置SSH公钥"></a>4.4、配置SSH公钥</h3><ul><li>生成SSH公钥<ul><li><code>ssh-keygen -t rsa</code></li><li>不断回车<ul><li>如果公钥已经存在，则自动覆盖</li></ul></li></ul></li><li>Gitee设置账户共公钥<ul><li>获取公钥<ul><li><code>cat ~/.ssh/id_rsa.pub</code></li></ul></li><li><img src="SSH公钥.png" alt="SSH公钥"  /></li><li>验证是否配置成功<ul><li><code>ssh -T git@gitee.com</code></li></ul></li></ul></li></ul><h3 id="4-5、操作远程仓库"><a href="#4-5、操作远程仓库" class="headerlink" title="4.5、操作远程仓库"></a>4.5、操作远程仓库</h3><h4 id="4-5-1、添加远程仓库"><a href="#4-5-1、添加远程仓库" class="headerlink" title="4.5.1、添加远程仓库"></a>4.5.1、添加远程仓库</h4><p><strong>此操作是先初始化本地库，然后与已创建的远程库进行对接。</strong></p><ul><li>命令： <code>git remote add &lt;远端名称&gt; &lt;仓库路径&gt;</code><ul><li>远端名称，默认是origin，取决于远端服务器设置</li><li>仓库路径，从远端服务器获取此URL</li><li>例如：<br><code>git remote add origin git@gitee.com:czbk_zhang_meng/git_test.git</code><br><code>&lt;img src=&quot;添加远程仓库.png&quot; alt=&quot;添加远程仓库&quot;  /&gt;</code></li></ul></li></ul><h4 id="4-5-2、查看远程仓库"><a href="#4-5-2、查看远程仓库" class="headerlink" title="4.5.2、查看远程仓库"></a>4.5.2、查看远程仓库</h4><ul><li>命令：<code>git remote</code><br><code>&lt;img src=&quot;查看远程仓库.png&quot; alt=&quot;/查看远程仓库&quot;  /&gt;</code></li></ul><h4 id="4-5-3、推送到远程仓库"><a href="#4-5-3、推送到远程仓库" class="headerlink" title="4.5.3、推送到远程仓库"></a>4.5.3、推送到远程仓库</h4><ul><li>命令：<code>git push[ -f][ --set-upstream][ 远端名称[ 本地分支名[:远端分支名]]]</code><ul><li>如果远程分支名和本地分支名称相同，则可以只写本地分支<ul><li><code>git push origin master</code>=<code>git push origin master:master</code><br><img src="/推送到远程仓库-两种写法.png" alt="推送到远程仓库-两种写法"></li></ul></li><li><code>-f</code> = <code>--force</code> 表示强制覆盖</li><li><code>-u</code> = <code>--set-upstream</code> 推送到远端的同时并且建立起和远端分支的关联关系。<ul><li><code>git branch -M master main</code></li><li><code>git push --set-upstream origin main</code></li></ul></li><li>如果<strong>当前分支已经和远端分支关联</strong>，则可以省略分支名和远端名。<ul><li><code>git push</code> 将master分支推送到已关联的远端分支。<br><img src="/推送到远程仓库.png" alt="推送到远程仓库"></li></ul></li></ul></li></ul><p>查询远程仓库</p><p><img src="/查询远程仓库.png" alt="查询远程仓库"></p><h4 id="4-5-4、-本地分支与远程分支的关联关系"><a href="#4-5-4、-本地分支与远程分支的关联关系" class="headerlink" title="4.5.4、 本地分支与远程分支的关联关系"></a>4.5.4、 本地分支与远程分支的关联关系</h4><ul><li>查看关联关系我们可以使用 <code>git branch -vv</code> 命令</li></ul><p><img src="/查看本地分支和远程分支的关联关系.png" alt="查看本地分支和远程分支的关联关系"></p><h4 id="4-5-5、从远程仓库克隆"><a href="#4-5-5、从远程仓库克隆" class="headerlink" title="4.5.5、从远程仓库克隆"></a>4.5.5、从远程仓库克隆</h4><p>如果已经有一个远端仓库，我们可以直接clone到本地。</p><ul><li>命令: <code>git clone &lt;仓库路径&gt; [本地目录]</code><ul><li>本地目录可以省略，会自动生成一个目录</li></ul></li></ul><p><img src="/克隆远程仓库到本地.png" alt="克隆远程仓库到本地"></p><h4 id="4-5-6、从远程仓库中抓取和拉取"><a href="#4-5-6、从远程仓库中抓取和拉取" class="headerlink" title="4.5.6、从远程仓库中抓取和拉取"></a>4.5.6、从远程仓库中抓取和拉取</h4><p>远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。</p><ul><li>抓取 命令：<code>git fetch [remote name] [branch name]</code><ul><li><strong>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</strong></li><li>如果不指定远端名称和分支名，则抓取所有分支。</li></ul></li><li>拉取 命令：<code>git pull [remote name] [branch name]</code><ul><li><strong>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</strong></li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul></li></ul><ol><li>在test01这个本地仓库进行一次提交并推送到远程仓库<br><img src="/在test01这个本地仓库进行一次提交并推送到远程仓库.png" alt="在test01这个本地仓库进行一次提交并推送到远程仓库"></li><li>在另一个仓库将远程提交的代码拉取到本地仓库<br><img src="/将仓库里远程提交的代码拉取到本地仓库.png" alt="将仓库里远程提交的代码拉取到本地仓库"></li></ol><h4 id="4-5-7、解决合并冲突"><a href="#4-5-7、解决合并冲突" class="headerlink" title="4.5.7、解决合并冲突"></a>4.5.7、解决合并冲突</h4><p>在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。</p><p>A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，<strong>故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支</strong>，如下图所示。</p><p><img src="/解决远程仓库合并冲突.png" alt="解决远程仓库合并冲突"></p><p>在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲突。</p><p><strong>远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同</strong>，在此不再赘述，需要学员自己练习。</p><h4 id="练习-远程仓库操作"><a href="#练习-远程仓库操作" class="headerlink" title="练习:远程仓库操作"></a>练习:远程仓库操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#########################1-将本地仓库推送到远程仓库</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完成4.1、4.2、4.3、4.4的操作</span></span><br><span class="line">略</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[git_test01]添加远程仓库</span></span><br><span class="line">git remote add origin git@gitee.com/**/**.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[git_test01]将master分支推送到远程仓库,并与远程仓库的master分支绑定关联关系</span></span><br><span class="line">git push --set-upstream origin master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################2-将远程仓库克隆到本地</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将远程仓库克隆到本地git_test02目录下</span></span><br><span class="line">git clone git@gitee.com/**/**.git git_test02</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[git_test02]以精简的方式显示提交记录</span></span><br><span class="line">git-log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################3-将本地修改推送到远程仓库</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[git_test01]创建文件file03.txt</span></span><br><span class="line">略</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[git_test01]将修改加入暂存区并提交到仓库,提交记录内容为：add file03</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;add file03&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[git_test01]将master分支的修改推送到远程仓库</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################4-将远程仓库的修改更新到本地</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[git_test02]将远程仓库修改再拉取到本地</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以精简的方式显示提交记录</span></span><br><span class="line">git-log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件变化(目录下也出现了file03.txt)</span></span><br><span class="line">略</span><br></pre></td></tr></table></figure><h4 id="移除远程仓库"><a href="#移除远程仓库" class="headerlink" title="移除远程仓库"></a>移除远程仓库</h4><ul><li>命令：<code>git remote rm &lt;remote-name&gt;</code> = <code>git remote remove &lt;remote-name&gt;</code></li></ul><h2 id="5、在Idea中使用Git"><a href="#5、在Idea中使用Git" class="headerlink" title="5、在Idea中使用Git"></a>5、在Idea中使用Git</h2><h3 id="5-1、在Idea中配置Git"><a href="#5-1、在Idea中配置Git" class="headerlink" title="5.1、在Idea中配置Git"></a>5.1、在Idea中配置Git</h3><p>安装好IntelliJ IDEA后，如果Git安装在默认路径下，那么idea会自动找到git的位置，如果更改了Git的安装位置则需要手动配置下Git的路径。选择File→Settings打开设置窗口，找到Version Control下的git选项：</p><p><img src="/在Idea中配置Git.png" alt="在Idea中配置Git"></p><p>点击Test按钮,现在执行成功，配置完成</p><p><img src="/在Idea中成功配置Git.png" alt="在Idea中成功配置Git"></p><h3 id="5-2、在Idea中操作Git"><a href="#5-2、在Idea中操作Git" class="headerlink" title="5.2、在Idea中操作Git"></a>5.2、在Idea中操作Git</h3><p>场景：本地已经有一个项目，但是并不是git项目，我们需要将这个放到码云的仓库里，和其他开发人员继续一起协作开发。</p><h4 id="5-2-1、创建项目远程仓库（参照4-3）"><a href="#5-2-1、创建项目远程仓库（参照4-3）" class="headerlink" title="5.2.1、创建项目远程仓库（参照4.3）"></a>5.2.1、创建项目远程仓库（参照4.3）</h4><p><img src="/IDEA-创建项目远程仓库.png" alt="IDEA-创建项目远程仓库"></p><h4 id="5-2-2、初始化本地仓库"><a href="#5-2-2、初始化本地仓库" class="headerlink" title="5.2.2、初始化本地仓库"></a>5.2.2、初始化本地仓库</h4><p><img src="/IDEA-初始化本地仓库.png" alt="IDEA-初始化本地仓库"></p><h4 id="5-2-3、设置远程仓库"><a href="#5-2-3、设置远程仓库" class="headerlink" title="5.2.3、设置远程仓库"></a>5.2.3、设置远程仓库</h4><p><img src="/IDEA-设置远程仓库.png" alt="IDEA-设置远程仓库"></p><h4 id="5-2-4、提交到本地仓库"><a href="#5-2-4、提交到本地仓库" class="headerlink" title="5.2.4、提交到本地仓库"></a>5.2.4、提交到本地仓库</h4><p><img src="/IDEA-提交到本地仓库.png" alt="IDEA-提交到本地仓库"></p><h4 id="5-2-6、推送到远程仓库"><a href="#5-2-6、推送到远程仓库" class="headerlink" title="5.2.6、推送到远程仓库"></a>5.2.6、推送到远程仓库</h4><p><img src="/IDEA-推送到远程仓库.png" alt="IDEA-推送到远程仓库"></p><h4 id="5-2-7、克隆远程仓库到本地"><a href="#5-2-7、克隆远程仓库到本地" class="headerlink" title="5.2.7、克隆远程仓库到本地"></a>5.2.7、克隆远程仓库到本地</h4><p><img src="/IDEA-克隆远程仓库到本地.png" alt="IDEA-克隆远程仓库到本地"></p><h4 id="5-2-8、创建分支"><a href="#5-2-8、创建分支" class="headerlink" title="5.2.8、创建分支"></a>5.2.8、创建分支</h4><ul><li>最常规的方式<br><img src="/IDEA-创建分支（常规）.png" alt="IDEA-创建分支（常规）"></li><li>最强大的的方式<br><img src="/IDEA-创建分支（强大）.png" alt="IDEA-创建分支（强大）"></li></ul><h4 id="5-2-9、切换分支及其他分支相关操作"><a href="#5-2-9、切换分支及其他分支相关操作" class="headerlink" title="5.2.9、切换分支及其他分支相关操作"></a>5.2.9、切换分支及其他分支相关操作</h4><p><img src="/IDEA-切换分支及其他分支相关操作.png" alt="IDEA-切换分支及其他分支相关操作"></p><h4 id="5-2-11、解决冲突"><a href="#5-2-11、解决冲突" class="headerlink" title="5.2.11、解决冲突"></a>5.2.11、解决冲突</h4><ol><li>执行merge或pull操作时，可能发生冲突<br><img src="/IDEA-解决冲突.png" alt="IDEA-解决冲突"></li><li>冲突解决后加入暂存区<br>略</li><li>提交到本地仓库<br>略</li><li>推送到远程仓库<br>略</li></ol><h3 id="5-3、IDEA常用GIT操作入口"><a href="#5-3、IDEA常用GIT操作入口" class="headerlink" title="5.3、IDEA常用GIT操作入口"></a>5.3、IDEA常用GIT操作入口</h3><ol><li>第一张图上的快捷入口可以基本满足开发的需求。<br><img src="/IDEA常用GIT操作入口1.png" alt="IDEA常用GIT操作入口"></li><li>第二张图是更多在IDEA操作git的入口。<br><img src="/IDEA常用GIT操作入口2.png" alt="IDEA常用GIT操作入口"></li></ol><h3 id="5-4、场景分析"><a href="#5-4、场景分析" class="headerlink" title="5.4、场景分析"></a>5.4、场景分析</h3><p>基于我们后面的实战模式，我们做一个综合练习</p><p>当前的开发环境如下，我们每个人都对这个项目已经开发一段时间，接下来我们要切换成团队开发模<br>式。</p><p>也就是我们由一个团队来完成这个项目实战的内容。团队有组长和若干组员组成（组长就是开发中的项<br>目经理）。</p><p>所有操作都在idea中完成。</p><p>练习场景如下：</p><ol><li>由组长，基于本项目创建本地仓库；创建远程仓库，推送项目到远程仓库。<br><img src="/综合练习-1.png" alt="综合练习-1"></li><li>每一位组员从远程仓库克隆项目到idea中,这样每位同学在自己电脑上就有了一个工作副本，可以正<br>式的开始开发了。我们模拟两个组员(组员A、组员B)，克隆两个工作区。<br><img src="/综合练习-2.png" alt="综合练习-2"></li><li>组员A修改工作区,提交到本地仓库，再推送到远程仓库。组员B可以直接从远程仓库获取最新的代<br>码。<br><img src="/综合练习-3.png" alt="综合练习-3"></li><li>组员A和组员B修改了同一个文件的同一行，提交到本地没有问题，但是推送到远程仓库时，后一个<br>推送操作就会失败。<br>解决方法：需要先获取远程仓库的代码到本地仓库，编辑冲突，提交并推送代码。<br><img src="/综合练习-4.png" alt="综合练习-4"></li></ol><h2 id="附-几条铁令"><a href="#附-几条铁令" class="headerlink" title="附:几条铁令"></a>附:几条铁令</h2><ol><li><strong>切换分支前先提交本地的修改</strong></li><li>代码及时提交，提交过了就不会丢</li><li>遇到任何问题都不要删除文件目录，第1时间找老师</li></ol><h2 id="附-疑难问题解决"><a href="#附-疑难问题解决" class="headerlink" title="附:疑难问题解决"></a>附:疑难问题解决</h2><h3 id="1-windows下看不到隐藏的文件（-bashrc、-gitignore）"><a href="#1-windows下看不到隐藏的文件（-bashrc、-gitignore）" class="headerlink" title="1. windows下看不到隐藏的文件（.bashrc、.gitignore）"></a>1. windows下看不到隐藏的文件（.bashrc、.gitignore）</h3><p><img src="/windows下查看隐藏文件.png" alt="windows下查看隐藏文件"></p><h3 id="2-windows下无法创建-ignore-bashrc文件"><a href="#2-windows下无法创建-ignore-bashrc文件" class="headerlink" title="2. windows下无法创建.ignore|.bashrc文件"></a>2. windows下无法创建.ignore|.bashrc文件</h3><p>这里以创建.ignore 文件为例：</p><ul><li>在git目录下打开gitbash</li><li>执行指令 <code>touch .gitignore</code></li></ul><p><img src="/windows下创建.ignore、.bashrc文件.png" alt="windows下创建.ignore、.bashrc文件"></p><h2 id="附：IDEA集成GitBash作为Terminal"><a href="#附：IDEA集成GitBash作为Terminal" class="headerlink" title="附：IDEA集成GitBash作为Terminal"></a>附：IDEA集成GitBash作为Terminal</h2><p><img src="/IDEA集成GitBash作为Terminal.png" alt="IDEA集成GitBash作为Terminal"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
